### JVM

1、类加载过程

2、JVM分区，对象如何到老年代

3、GC算法，常见的垃圾收集器

4、oom报错类型及原因

5、类加载机制双亲委派模型

6、JVM的内存模型

7、讲一下Full GC

（1）调用system.gc，只是建议虚拟机执行FullGC，但虚拟机不一定真正去执行

（2）年轻代空间不足：老年代空间不足的场景为前文所讲的大对象直接进入老年区、长期存活的对象进入老年区等，为了避免以上原因引起的FullGC，应尽量不要创建过大的对象数组，除此之外还可以通过Xmm虚拟机参数调整新生代大小，让对象尽量在新生代多存活一段时间。

（3）空间分配担保失败：使用复制算法的MinorGC需要老年代的内存空间做担保，如果担保失败会执行一次FullGC

8、频繁FullGC有什么问题？如何排查？

系统性能变低，一般FullGC不会频繁执行，如果出现了就要去查看一下是不是创建大对象或者空间分配担保失败，调参数printGCDetail命令

百度：

> 说一下JVM模型，有哪些区？分别干什么？

蚂蚁金服：

> Java8内存分代改进

> JVM内存分那些区，每个区的作用？

> JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么有两个survivor区？

小米：

> JVM内存分区，为什么要有新生代和老年代

字节：

> Java内存分区

> JVM运行时数据区

> 什么时候对象会进入老年代？

京东：

> JVM内存结构，eden和survivor比例？

> JVM内存为什么要分成新生代、老年代、永久代以及新生代为什么要为eden和survivor

天猫：

> JVM内存模型以及分区，需要详细说到每个区放什么

> JVM的内存模型，Java8做了什么修改？

拼多多：

> JVM内存分哪几个区，每个区的作用时什么？

美团：

> Java内存分配

> JVM的永久代中会发生垃圾回收吗？

> JVM内存分区，为什么要有新生代和老年代？

美团：

> 对象在JVM中是怎么存储？
>
> 对象头信息里面有哪些东西？

蚂蚁金服：

> Java对象头有什么？







### Java

1、equals和==区别？

（1）基本数据类型，比较的是值

（2）引用类型：比较的是内存地址是否相等，equals一样，但是大多数情况下equals会重写，按照重写的规则进行比较，比如string里的equals重写了，就是比较字符串的内容，一般重写equals还会重写hashcode的，

2、为什么重写equals还要重写hashcode，不写会怎么样？

hashcode相等，equals不一定相等，但是如果equals相同，hashcode移动相同。举个map例子，存放的时候先进比较hashcode然后再比较equals，如果只重写的话，对象比较的时候会出错。

3、finally语句是怎么用的？

try catch语句后面用finally，一般附带一个语句块，无论是否抛出异常都会执行finally后面的语句块，一般使用与释放资源。

