> 一个寂寞难耐的夜晚，使内心久久不能沉静下来，我痛定思痛，于是决定开始写互联网技术栈面试《360度剖析吊打面试官系列》

#### 小伙子，我看你简历写着熟悉Java集合。那我们直接正入主题吧，List、Set、Map有什么区别？

帅气的面试你好？ List 和 Set 都是collection 的子接口，List的存储元素是有序的，可以重复的；而 Set 存储是无序的，可不重复的；Map 是键值对形式存储的，Key 不允许重复，但允许且有一个null，value可以重复的。



#### 1连问：那你说一下 ArrayList 和 LinkedList 区别吧？

* ArrayList 和 LinkedList 线程都是不安全的。线程安全的使用vector
* 底层实现不同：ArrayList底层实现是数组，而LinkedList 底层是维护着双向链表数据结构。
* 由于ArrayList底层是数据实现的，所以删除和插入元素时效率很低，因为需要移动元素，而LinkedList底层是双向链表所以增删效率快。



#### 2连问：你帮我回忆一下 ArrayList 扩容机制，我想不起来？

你个糟老头子，坏得很？明明是在刁难我，还说自己忘记了，看你这发型我不敢相信忘记。放心我这回面试准备是吊打你的。

当你创建ArrayList对象时，不指定容量大小，那么默认会调用一个空容量，第一次添加元素时，初始扩容为10，之后再次扩容时都是按照1.5倍进行扩容的。扩容机制底层，内部调用Arrays.copyOf 拷贝数组操作的System.arrayCopy()方法。源码可以看。



#### 3连问：那我们再聊一聊HashMap 和 Hashtble 吧，你说说他的区别？

* HashMap是非线程安全的，Hashtable是线程安全的，因为Hashtable内部方法基本都是经过synchronized修饰，要保证线程安全的话，基本上使用ConcurrentHashMap。
* 从效率角度看，HashMap效率高于Hashtable的
* HashMap的key只允许有一个null且不能为空，value为可以有多个null，而Hashtable的Key和value都是不允许为null，否则会抛出空指针异常（NullPointerException）
* 初始扩容和每次扩容都不同的，HashMap默认初始化大小为16，临界值为12就进行扩容，之后扩容是2倍进行；创建HashMap对象时给定大小，那么会将其扩容为2的幂次方大小。
* 底层数据结构不同：JDK8以后HashMap在解决哈希冲突时有很大变化，当链表长度大于8，且当前HashMap的table表长度大于64，会转成红黑树，如果链表长度大于8，但是当前数组长度没有达到64，仍然以数组方式进行扩容，Hashtable没有这样的机制。

> 刚才你说是以2幂次方，为什么？

此时你会心想，这面试官这么小细节还在追问，何必为难我呢？还好我牛逼，不然今天被你吊打吃不下饭。

HashMap的长度为什么是2的幂次方，其实就是为让HashMap存取高效，减少Hash碰撞，也就是为了将数据分配均匀的。

> 此时面试官还会问：你说到Hash碰撞问题，那么如果Hash碰撞你是如何解决的？

#### 4连问：HashMap 扩容机制？JDK 1.7 和 JDK 1.8 有什么区别？

JDK 1.8 之前 HashMap 底层是【数组+链表】实现的。JDK1.8及以后在解决哈希冲突有了很大的变化，底层使用【数组+链表+红黑树】的方式，当链表长度大于8时，转红黑树。转黑红树的前提条件是：链表长度大于8，且当前数组大于64，就转红黑树，如果只满足链表长度大于8，且当前数组小于64，仍然以数组方式进行扩容。

#### 5连问：刚才提到线程安全，ConcurrentHashMap 和 Hashtable 的区别？

* 底层数据结构不同：JDK1.7 的 ConcurrentHashMap 底层采⽤【分段的数组+链表】 实现，JDK1.8 采⽤的数据结构跟 HashMap1.8 的结构⼀样，数组+链表/红⿊⼆叉树。而Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ 【数组+链表】 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的；
* 实现线程安全的⽅式（重要）不同：JDK1.7 的时候， ConcurrentHashMap （分段锁） 对整个桶数组进⾏了分割分段( Segment )，每⼀把锁只锁容器其中⼀部分数据，多线程访问 容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经 摒弃了 Segment 的概念，⽽是直接⽤ 【Node 数组+链表+红⿊树】的数据结构来实现，并发 控制使⽤ synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap ，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable (同⼀把 锁) :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其 他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不 能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。

> 可能连问：CAS 是什么？synchronized在1.6以后做了哪些优化？
>
> 此时你心想要是身边又个锥子，恨不得把面试官打一顿，但我们有心而不敢，对不对？CAS 和synchronized要是扯起来估计很长时间，我们放到线程那时候来详细说明。

#### ConcurrentHashMap 如何实现线程安全的？底层有了解吗？

JDK 1.7以前采用分段锁实现，但到JDK 1.8 后采用 CAS  和 synchronized 来保证并发安全。底层数据结构和HashMap1.8结构一样（数组+链表+红黑树）。synchronized 只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要 hash 不冲突，就不会产⽣并 发，效率⼜提升 N 倍。

