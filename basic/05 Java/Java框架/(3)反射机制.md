反射：在学习框架时候使用特别多，即通过外部文件配置，在不修改源代码情况下，来控制程序，也符合设计模式OCP原则（开闭原则，也就是不修改源码扩展功能）

入门案例：

```java
public class ReflectionQuestion {
    public static void main(String[] args) throws IOException, ClassNotFoundException,
            InstantiationException, IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {
        //方式1
//        Cat cat = new Cat();
//        cat.hi();
        //方式二
        Properties properties = new Properties();
        properties.load(new FileInputStream("src/re.properties"));
        String classfullpath = properties.get("classfullpath").toString();
        String methodName = properties.get("method").toString();
        //方式三：反射
        //(1)加载类，返回class类型的对象cls
        Class als = Class.forName(classfullpath);
        //(2)通过cls得到你加载的类，com.haxdeu.Cat对象
        Object o = als.newInstance();
        //(3)通过cls得到你加载类com.haxdeu.Cat对象的methodName 的方法
        //在反射中，方法可以当作对象
        Method method1 = als.getMethod(methodName);
        System.out.println("==============");
        //(4)通过method1 调用方法
        method1.invoke(o);


    }
}

```

### 反射机制

* 反射机制允许程序在执行期借助Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法。反射在设计模式和框架底层都会使用到
* 加载完类之后，在堆中生产了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称为：反射



反射机制主要方法：

1. java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象
2. java.lang.reflect.Method：代表类的方法
3. java.lang.reflect.Field：代表类的成员变量
4. java.lang.reflect.Constructor：代表类的构造器方法



反射优缺点：

优点：可以动态的创建和使用对象，使用比较灵活，没有反射机制，框架技术就失去底层支撑。

缺点：使用反射基本是解释执行，对执行速度有影响



### Class类

1. Class也是类，因此也继承Object类
2. Class类对象不是new出来的，而是系统创建的
3. 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次
4. 每个类的实例都会记得自己是由哪个Class实例生成
5. 通过Class可以完整地得到一个类的完整结构，通过一系列API
6. Class对象是存放在堆
7. 类的字节码二进制数据，是放在方法区的，有的地方称为的元数据