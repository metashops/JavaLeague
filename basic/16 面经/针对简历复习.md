#### 专业技能：

* 熟悉 Java 基础，多线程、深入学习过 ArrayList、HashMap、ConcurrentHashMap 等常用集合的源码
* 对 JVM 原理、垃圾收集机制、synchronized、Volatile 关键字的理解、及 CAS 乐观锁技术有一定了解
* 熟悉掌握 Spring MVC、MyBatis、Spring Boot 等主流框架，并能使用 maven 进行项目框架搭建
* 熟练 SQL 语言，并且熟悉使用 MySQL 数据库基本操作
* 熟悉使用 IDEA、及 Git 等工具使用；以及能进行 Linux、docker 基本操作

#### 项目经验：

**项目名称**：XXX

**项目描述**：淘宝网是亚太地区较大的网络零售、商圈，由阿里巴巴集团在2003年5月创立。淘宝网是中国深受欢迎的网购零售平台，拥有近5亿的注册用户数，每天有超过6000万的固定访客，同时每天的在线商品数已经超过了8亿件，平均每分钟售出4.8万件商品。

**涉及技术**：Spirng、SpringMVC、MyBatis、Redis、MySQL、Dubbo、RocketMQ、ELK等

**设计技术**：

1、采用分布式的项目开发模式整个项目分为：订单、综合管理、社交、crm、用户、商品中台、

统计、供应链、支付、canal阿里开源框架、odps 数据分析、ELK等二十多个服务。

2、基于RocketMQ支持消息事务这一特点，在项目开发过程中使用这一特点，采用最大努力通知的	分布式事务解决方案去处理分布式事务场景。

3、基于Redis消息中间件，实现了购物车，接口幂等，秒杀活动等高并发访问场景的开发。

4、对数据量较大的表使用Sharding-JDBC数据库中间件在主从同步，从从同步的基础上实现了分库	分表，读写分离。

5、采用Elasticsearch , Logstash, Kibana这套经典组合，实现了数据库数据同步Es大幅提升了高	并发场景的搜索效率，并采用ik中文分词器强化了分词搜索的功能，线上错误日志收集，提升开发	人员线上问题的错误日志定位效率，并且在组合上加入了阿里开发框架Canal在数据同步效率上也	有了很大的提升。

**项目收获**：

通过该项目的开发，让我对高并发，大数据量等业务场景有了自己的认识，也知道在什么样的场景下，结合Redis以及RocketMQ等中间件的使用提高服务性能效率，以及面对高并发的场景做怎样的及时应对，特别是双十二的一次事故让自己逐渐成长，在公司期间也让自己对自己的职业道路有了更清晰的规划，对自己的代码有了严格的要求，leader每次review代码也能发现我的成长。在阿里系师兄们的带领下，让自己有了不同传统企业的代码和业务思想，从需求评审、视觉评审、到自己的概要设计、详细设计、开发、联调、提测、灰度、生产上线每个环节，不断收获总结。

---

## 线程部分

线程创建方式有哪些？

线程启动方式有哪些？

线程状态？

#### synchronized底层实现？

（1）Synchronized一般适用于以下几种场景：

* 修饰实例方法，锁是当前实例对象

  ```java
  public class Sync1 {
      public synchronized void test1(){
      }
  }
  ```

* 修饰静态方法，锁是当前类的Class对象

  ```java
  public class Sync2 {
      public void test2(){
          synchronized(Synchronized.class){
          }
      }
  }
  ```

* 修饰代码块，指定一个加锁的对象，给对象加锁

  ```java
  public class Sync3 {
      public void test3(){
          synchronized(new test()){
          }
      }
  }
  ```

  

  （2）synchronized底层的实现原理？

  synchronized底层的实现是基于monitorenter 和 monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处的，当线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。上面提高的monitorenter和monitorexit指令的底层是lock和unlock指令。

  （3）jdk1.6 synchronized做了哪些优化？

  Java 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁有4种状态从低到高：无锁-偏向锁-轻量级锁-重量级锁，锁的升级不可逆的，偏向锁在1.6之后是默认开启的，1.5中是关闭的，需要手动开启参数是xx:-UseBiasedLocking=false。

  （4）锁升级过程？

  偏向锁如果有线程竞争时，会发生偏向锁的撤销并升级为自旋锁。如果锁竞争情况严重，达到自旋锁默认10次数后(-XX：PreBlockSpin可以修改)，会升级为重量级锁。重量级锁就会去操作系统请求资源，相当于用户态变为内核态，系统开销大。
  
  

synchronized 和 Lock 区别？

* synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API
* synchronized会自动释放锁，而Lock必须手动释放锁
* synchronized是不可中断的，Lock可以中断也可以不中断
* synchronized能锁住方法和代码块，而Lock只能锁住代码块
* synchronized是非公平锁，ReentrantLock可以控制是否是公平锁

> synchronized缺点：在某些场景下我觉得锁升级过程是不可逆的缺点吧，比如滴滴打车，如果使用大量的synchronized，过了高峰值锁还是重量级锁，那效率就非常低，而且系统开销也很大。

Volatile 关键字

Volatile是一个变量修饰符，只能用来修饰变量。volatile保证不同线程对共享变量操作的可见性，但不能保证原子性，如果当一个线程修改了volatile修饰的变量时，另一个线程立马可以看到。使用Volatile作用还可以禁止指令重新排序，

造成可见性原因？

在Java中造成可见性问题的原因是Java内存模型(JMM)，在Java内存模型中，规定了共享变量是存放在主内存中，然后每个线程都有自己的工作内存，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。