> 递归 枚举、贫心、回溯、动态规划

## 哈希表

散列表(hash table也叫哈希表)，是根据关键码值(key-value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

> 案例：
>
> 比如使用校园系统添加一个学生到校园系统去，输入学号可以查询出该学生所有信息
>
> 要求：
>
> * 添加学生编号时，按照从低到高的顺序
> * 使用链表来实现哈希表，该链表不带表头



## 二叉树

#### 介绍

二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也是简单地转换为二叉树，而且二叉树的存储结构以及算法都比较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。

#### 二叉树三种遍历：

前序遍历：先输出父结点，再遍历左子树和右子树

> 分析步骤：
>
> （1）先输出当前节点（初始的时候是root节点）
>
> （2）如果左子节点不为空，则递归继续向前遍历
>
> （3）如果右子节点不为空，则递归继续向前遍历

中序遍历：先遍历左子树，再遍历父结点，再遍历右子树

> 分析步骤：
>
> （1）如果当前节点左子节点不为空，则递归继续向前遍历
>
> （2）输出当前节点
>
> （3）如果右子节点不为空，则递归继续向前遍历

后序遍历：先遍历左子树，再遍历右子树，最后遍历父结点

> 分析：
>
> （1）如果当前节点左子节点不为空，则递归继续向前遍历
>
> （2）如果当前节点右子节点不为空，则递归继续向前遍历
>
> （3）输出当前节点



#### 二叉树查询

前序查询

> 思路：
>
> （1）先判断当前结点的no是否等于要查找的结点
>
> （2）如果是相等，则返回当前节点
>
> （3）如果不相等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
>
> （4）如果左递归前序查找找到，则返回。否则继续判断，当前节点的结点的右子节点是否为空，不为空，则继续向右递归前序查找。

中序查询

> 思路：
>
> （1）判断当前结点的左子节点是否为空，不为空，则递归中序查找
>
> （2）如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归中序查找
>
> （3）如果右递归中序查找到则返回，否则返回null

后序查询

> （1）判断当前结点的左节点是否为空，如果不为空，则递归后序查找
>
> （2）如果找到，就返回，如果没有找到，就判断 当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到就返回
>
> （3）就喝当前结点进行，比如，如果是则返回，否则返回null



#### 二叉树删除

简单版删除：（要求）

如果删除的节点是叶子节点，则删除该节点

如果删除节点是非叶子节点，则删除该子树

> 思路：
>
> 首先：考虑空树，如果只有一个root，则等价将二叉树设置为空
>
> （1）因为我们二叉树是单向的，所以我们是判断结点的子节点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点
>
> （2）如果当前结点的左子结点不为空，并且左子结点就是要删除节点，就将this.left=null；并且就返回（结束递归删除）
>
> （3）如果当前结点的右子结点不为空，并且左子结点就是要删除的结点，就将this.right=null；并且就返回（结束递归删除）
>
> （4）如果第2和第3步没有删除结点那么我们就需要向左子树进行递归删除
>
> （5）如果第4步也没有删除芥结点，则应当向右子树进行递归删除



#### 顺序存储二叉树

顺序存储二叉树，我们以一个案例为解释就懂了。

要求：

> 给你一个数组{1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应该为：1,2,4,5,3,6,7

```java
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};
        //创建ArrBinaryTree
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        arrBinaryTree.preOrder();
    }
}
class ArrBinaryTree {
    private int[] arr;
    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }
    // 重载
    public void preOrder() {
        this.preOrder(0);
    }
    public void preOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能遍历！");
        }
        System.out.println(arr[index]);
        // 左递归遍历
        if ((index * 2 + 1) < arr.length) {
            preOrder(2 * index + 1);
        }
        // 右递归遍历
        if ((index * 2 + 2) < arr.length) {
            preOrder(2 * index + 2);
        }
    }
}
```

#### 赫夫曼树与编码原理

介绍

给定n个权值作为n个叶子结点，结构一颗二叉树，若该树的带权路径长度(wpl)达到最小，称为最优二叉树。

赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

步骤：

> （1）从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一个颗最简单的二叉树
>
> （2）取出根节点权值最小的两颗
>
> （3）组成一颗新的二叉树，该新的二叉树根节点的权值是前两颗二叉树根节点权值的和
>
> （4）再将这颗新的二叉树，以根节点的权值再次排序，不断重复1-2-3-4步骤，直到数列中，所有的数据被处理完得到一颗赫夫曼树。
