> 链表，二叉树，二分查找，动态规划，哈希表
>
> 三部曲：看懂题目 > 分析推导解法 > 将思路转换为代码
>
> 数据库设计-计算机组成原理-计算机网络-数据结构-设计模式

## 哈希表

## 242、题目描述：

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

示例 1:

> 输入: s = "anagram", t = "nagaram"
>
> 输出: true

示例 2:

> 输入: s = "rats", t = "cars"
> 输出: false

解题思路：方法（哈希表）

 * 1,t是s的异位词，是指等价t,s字符串中的字符出现种类和次数均相等
 * 2,由于字符串包含26个小写字母，所以我们可以维护一个长为26数组table
 * 3,如何编写我们逻辑代码呢？
 * 3.1 首先遍历记录字符串s中的字符出现频次s[i] - ‘a’，这样就可以统计s出现频次了
 * 3.2 然后遍历字符串t，对t中出现的字符映射table索引上的数值再做-1的操作。
 * 3.2 如果减去后，table != 0,说明t包含一个不在s中的，返回false
 * 3.3 table数组所有元素都为零0，说明字符串s和t是字母异位词,返回true

```java
public class LeeTCode {
    public boolean isAnagram(String s,String t) {
        int[] recode  = new int[26];
        //toCharArray()将字符串对象中的字符转换为一个字符数组
        for (char c : s.toCharArray()) {
            recode[c - 'a'] += 1;//相当于a=a+1
        }
        for (char c : t.toCharArray()) {
            recode[c - 'a'] -= 1;
        }
        for (int i : recode) {
            if (i != 0) {
                return false;
            }
        }
        return true;
    }
}
```



## 349. 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

>```
>输入：nums1 = [1,2,2,1], nums2 = [2,2]
>输出：[2]
>```

**示例 2：**

>```
>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
>输出：[9,4]
>```

**说明：**输出结果中的每个元素一定是唯一的，我们可以不考虑输出结果的顺序。

```java
public class LeeTCode349 {
    public int[] intersection(int[] nums1,int[] nums2) {
        //先见简单判断
        if (nums1 == null || nums1.length == 0 || nums2 == null
                || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet1 = new HashSet<>();
        for (int i : nums1) {
            set1.add(i);
        }
        //遍历数组2的过程中判断哈希表中是否存在该元素
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet1.add(i);
            }
        }
        int[] resArr = new int[resSet1.size()];
        int index = 0;
        //将结果几何转为数组
        for (int i :resSet1) {
            resArr[index++] = i;
        }
        return resArr;
    }
}

```



## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：

> 输入：nums = [3,2,4], target = 6
> 输出：[1,2]

示例 3：

> 输入：nums = [3,3], target = 6
> 输出：[0,1]

```java
public class LeeTCode1 {
    class Solution {
        public int[] twoSum(int[] nums, int target) {
            int[] res = new int[2];
            if (nums == nums || nums.length == 0) {
                return res;
            }
            Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
            for (int i = 0; i < nums.length; ++i) {
                int temp = target - nums[i];
                if (hashtable.containsKey(temp)) {
                    res[1] = i;
                    res[0] = hashtable.get(temp);
                }
                hashtable.put(nums[i], i);
            }
            return res;
        }
    }
}
```



#### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

例如:

```java
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2
解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

```

```java
/**
 * 给定四个包含整数的数组列表 A , B , C , D ,
 * 计算有多少个元组 (i, j, k, l) ，
 * 使得 A[i] + B[j] + C[k] + D[l] = 0。
 */
public class LeeTCode454 {
    public int fourSumCont(int[] nums1,int[] nums2,int[] nums3,int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int temp;
        int res = 0;
        //1，先遍历A和B，统计两个数组中的元素之和，和出现的次数，放入map
        for (int i: nums1) {
            for (int j: nums2) {
                temp = i + j;
                if (map.containsKey(temp)) {
                    map.put(temp,map.get(temp)+1);
                } else {
                    map.put(temp,1);
                }
            }
        }
        //2，在遍历C和D两个数组中的元素之和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i: nums3) {
            for (int j: nums4) {
                temp = i + j;
                if (map.containsKey(temp)) {
                    res += map.get(0-temp);
                }
            }
        }
        return res;
    }
}
/**
 * containsKey是判断是否包含指定的键名
 * 1，四个数组分成两部分:A和B一组，C和D一组
 * 2，对于A和B使用二重循环遍历，得到所有的A[i]+B[j]的值并放入哈希映射中
 * 3，对于哈希映射中每个键值对。每个键表示一种A[i]+B[j]，对应的值为A[i]+B[j]出现的次数
 */
```



```java
public class Demo1 {
    public static void main(String[] args) {
        HashMap<Object, Object> hashMap = new HashMap<>();
        hashMap.put("apple", "新鲜的苹果");
        hashMap.put("computer", "配置优良的计算机");
        hashMap.put("book", "堆积成山的图书");
        String key = "book";
        boolean contains = hashMap.containsKey(key);
        if (contains) {
            System.out.println("OK"+key);
        } else {
            System.out.println("no ok" + key);
        }
    }
}
```

运行结果：

```java
在Map集合中包含键名book
```



## 第15题：三数之和

> 给你一个包含 n 个整数的数组nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

解题思路：

```java
public class LeeTCode15 {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        //先排序
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                return result;
            }
            if (i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                }else if(sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
    public static void main(String[] args) {
        LeeTCode15 leeTCode15 = new LeeTCode15();
        int[] nums = {-1,0,1,2,-1,-4};
        List<List<Integer>> lists = leeTCode15.threeSum(nums);
        System.out.println(lists);
    }
}

```

## 第18题：四数之和

#### [LeetCode18题链接](https://leetcode-cn.com/problems/4sum/)

题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。





## 二叉树



