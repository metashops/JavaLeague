```
public class IterationBinaryTreeDemo {
    public static void main(String[] args) {
        TreeNode1 node9 = new TreeNode1(9, null, null);
        TreeNode1 node8 = new TreeNode1(8, null, null);
        TreeNode1 node7 = new TreeNode1(7, node8, node9);
        TreeNode1 node6 = new TreeNode1(6, null, null);
        TreeNode1 node5 = new TreeNode1(5, node6, node7);
        TreeNode1 node4 = new TreeNode1(4, null, null);
        TreeNode1 node3 = new TreeNode1(3, null, null);
        TreeNode1 node2 = new TreeNode1(2, node4, node5);
        TreeNode1 node1 = new TreeNode1(1, node2, node3);
        //preOrder2(node1);
        //infixOrder2(node1);
        levelOrder2(node1);
    }
    //迭代·前序遍历：根 左 右
    public static void preOrder2(TreeNode1 root) {
        if (root != null) {
            Stack<TreeNode1> stack = new Stack<TreeNode1>();
            stack.add(root);
            while (!stack.isEmpty()) {
                root = stack.pop();
                if (root != null) {
                    //打印根节点完后，将左右结点入栈
                    System.out.println(root.val);
                    stack.push(root.right);
                    stack.push(root.left);
                }
            }
        }
    }
    //迭代·中序遍历：左 根 右
    public static void infixOrder2(TreeNode1 root) {
        if (root != null) {
            Stack<TreeNode1> stack = new Stack<TreeNode1>();
            while (!stack.isEmpty() || root.left != null) {
                if (root != null) {
                    stack.push(root);
                    root = root.left;//left!=null就继续找
                } else {
                    root = stack.pop();//当最左边找到就出栈
                    System.out.println(root.val);
                    root = root.right;
                }
            }
        }
    }
    //迭代·中序遍历：左 右 根
    public static void postOrder2(TreeNode1 root) {
        if (root != null) {
            TreeNode1 prev = null;
            Stack<TreeNode1> stack = new Stack<TreeNode1>();
            while (!stack.isEmpty() || root.left != null) {
                if (root != null) {
                    stack.push(root);//入栈
                    root = root.left;//left!=null就继续找
                }
                root = stack.pop();
                if (root.right == null || root.right == prev) {
                    System.out.println(root.val);
                    prev = root;
                    root = null;
                } else {
                    stack.push(root);
                    root = root.right;
                }
            }
        }
    }
    //迭代·中序遍历：上中下
    public static void levelOrder2(TreeNode1 root) {
        Queue<TreeNode1> q = new LinkedList<>();
        q.add(root);
        while (!q.isEmpty()) {//队列不为空，就出队
            TreeNode1 node = q.poll();
            if (node != null) {
                System.out.println(node.val);
                q.add(node.left);
                q.add(node.right);
            }
        }
    }
}
class TreeNode1 {
    int val;
    TreeNode1 left;
    TreeNode1 right;
    public int deep;//深度
    public TreeNode1(int val, TreeNode1 left, TreeNode1 right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```