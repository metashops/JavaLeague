## 第1章	绪论

## 第2章	线性表

### 2.1	顺序存储结构

#### 2.2.1	顺序表的定义

（1）顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也是相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

```c
typedef struct {
  int num;    //号数
  int people; //人数
} Customer;
```

（2）如何知道一个数据元素大小？使用C语言`sizeof(ElemType)`

（3）静态分配

```c
#define MaxSize 10         //定义一个最大长度（根据需求定义大小）
typedef struct{
  ElemType data[MaxSize]; //用静态的“数组”存放的数据元素（一旦确定了不能改变）
  int length;              //顺序表的当前长度
}Sqlist;                   //顺序表的类型定义（静态分配方式）
//基本操作：初始化一个顺序表
void InitList(Sqlist &L) {
  for(int i = 0; i < MaxSize; i++)
    L.data[i] = 0; //将所有数据元素设置为默认初始化值
  L.length = 0; //顺序表初始化长度为0
}
int main() {
  SqList L; //声明一个顺序表
  InitList(L); //初始化顺序表
  return;
}
```

```c
#include "test.h"
#define MaxSize 10
typedef struct{
    int data[MaxSize]; //用静态的“数组”存放的数据元素（一旦确定了不能改变）
    int length;              //顺序表的当前长度
}SqList;                   //顺序表的类型定义（静态分配方式）
//基本操作：初始化一个顺序表
void InitList(SqList node) {
    node.length = 0; //顺序表初始化长度为0
}
int main() {
    SqList node; //声明一个顺序表
    InitList(node); //初始化顺序表
    for(int i = 0; i < MaxSize; i++)
        printf("data[%d]=%d\n",i,node.data[i]);
    return 0;
}
```

运行结果

```c
data[0]=0
data[1]=0
data[2]=0
data[3]=0
data[4]=0
data[5]=0
data[6]=0
data[7]=0
data[8]=-272632480
data[9]=32766
//后面两个位置为什么有数据？答案内存中会遗留的“脏数据”
```

（4）动态分配

```c
#include "test.h"
#include <stdlib.h>
#define InitSize 10          //顺序初始长度
typedef struct{
    int *data;               //动态分配d数组的指针
    int length;              //顺序表的当前长度
    int MaxSize;             //顺序表的最大容量
}SqList;                     //顺序表的类型定义（动态方式）
//基本操作：初始化一个顺序表
void InitList(SqList node) {
    node.data = (int *)malloc(InitSize*sizeof(int));
    node.length = 0;
    node.MaxSize=InitSize;
}
//增加动态数组的长度
void IncreaseSize(SqList node,int len) {
    int *p = node.data;
    node.data = (int*)malloc((node.MaxSize + len)*sizeof(int));
    for (int i = 0; i < node.length; i++) {
        node.data[i] = p[i];//将数据复制到新区域
    }
    node.MaxSize = node.MaxSize + len;//顺序表 最大z长度+len
    free(p);//释放原来的内存空间
}
int main() {
    SqList node; //声明一个顺序表
    InitList(node); //初始化顺序表
    IncreaseSize(node, 5);
    printf("<#const char *restrict, ...#>");
    return 0;
}
```

注：动态申请和释放内存空间C语言提供了`malloc and free`函数

`L.data = (int*)malloc(sizeof(int)*InitSize);`

（5）总结

顺序存储特点：

* 随机访问，可以在O(1)时间内找到第i个元素
* 存储密度高
* 拓展容量不方便
* 插入、删除操作不方便，因为需要移动大量元素

### 2.2.2	顺序表增删改查操作

（1）插入

ListInsert(&L,i,e)：插入操作，在表L中的第i个位置插入指定元素e

使用静态存储方式插入

```c
#define MaxSize 10
typedef struct {
  int data[MaxSize];
  int length;
}SqList;
#插入操作
void ListInsert(SqList &L,int i,int e) {
  if (i > L.length+1 || i < 1) {
    return "检查数据是否合法！";
  }
  if(L.length > MaxSinze) {
    return "存储空间已满";
  }
  for (int j = L.length; j >= i, j--){
    L.data[j] = L.data[j-1];
  }
  L.data[i-1] = e
  L.length++;
  return true;
}
int main() {
    SqList L; //声明一个顺序表
    InitList(L); //初始化顺序表
    ListInsert(L,3,3);
    return 0;
}
```

（2）删除

```c
#define MaxSize 10
typedef struct {
  int data[MaxSize];
  int length;
}SqList;
#插入操作
bool ListDelete(SqList &L,int i,int &e) {
  if (i > L.length+1 || i < 1) {
    return "检查数据是否合法！";
   e = L,data[i-1];//将要删除的e元素复制到e中
  }
  for (int j = i; j <= L.length, j++){
    L.data[j-1] = L.data[j];
  }
  L.length--;
  return true;
}
int main() {
    SqList L; //声明一个顺序表
    InitList(L); //初始化顺序表
    int e = -1;
    ListInsert(L,3,3);
    if (ListDelete(L,3,e)) {
      printf("删除的值为%d\n",e);
    } else {
      printf("位序i不合法，删除失败\n");
    }
    return 0;
}
```

（3）查找

```c
typedef strucr {
  int *data;
  int MaxSize;
  int length;
}SeqList;
//在顺序表L中查找第一个元素值等于e的元素，并返回其位序
int LocateElem(SeqList L,int e) {
  for (int i = 0; i < L.length; i++) {
    if (L.data[i] == e) {
      return i+1;
    }
  }
  return 0;
}
```

>顺序表优缺点：
>
>* 优点：可随机存取，存储密度高
>* 缺点：要求大片连续空间，改变容量不方便

### 2.3	链表（链式存储）

> 单链表优缺点：
>
> * 优点：不需要大片连续空间，改变容量方便
> * 缺点：不可随机存取，要耗费一定空间存放指针

（1）定义单链表

```c
struct LNode {
  ElemType data;      //定义单链表节点类型称：数据域
  struct LNode *next; //每个节点存放一个数据元素
};
//malloc，增加一个新的节点，在内存中申请一个节点所需空间，并用指针p指向这个节点
struct LNode *p = (struct LNode*)malloc(sizeof(struct LNode));
```

优化代码

```c
typedef struct LNode {
  ElemType data;
  struct LNode *next;
}LNode,*LinkList;
```

不带头节点的单链表

```c
typedef struct LNode {
  ElemType data;
  struct LNode *next;
}LNode,*LinkList;
//初始化一个空的单链表
bool InitList(LinkList &L) {
  L = NULL;//空表，暂时还没有任何节点
  return true;
}
void test(){
  LinkLinst L;//只是声明一个单链表的指针
  InitList(L);//初始化一个空链表
}
```

带头节点的单链表

```c
typedef struct LNode {
  ElemType data;
  struct LNode *next;
}LNode,*LinkList;
//初始化一个空的单链表
bool InitList(LinkList &L) {
  L = (LNode *)malloc(sizeof(LNode));//分配一个头节点
  if (L == NULL)
    return false;
  L -> next = NULL;//头节点之后暂时还没有节点
  return true;
  L = NULL;//空表，暂时还没有任何节点
  return true;
}
void test(){
  LinkLinst L;//只是声明一个单链表的指针
  InitList(L);//初始化一个空链表
}
```

#### 2.3.2	单链表插入和删除

（1）尾插完整代码

> 新建一个`test.h`文件

```c
#ifndef test_h
#define test_h
#include <stdio.h>
#endif /* test_h */
typedef int SListDataType;
typedef struct SListNode {
    SListDataType data;
    struct SListNode* next;
}SListNode;

SListNode* BuySListNode(SListDataType x) {
    SListNode* newNode = (SListNode*)malloc(sizeof(SListNode));
    if (newNode == NULL) {
        printf("申请失败...\n");
        exit(-1);
    }
    newNode -> data = x;
    newNode -> next = NULL;
    return newNode;
}
void SListPushBack(SListNode** pphead,SListDataType x) {
    SListNode* newNode = BuySListNode(x);
    if (*pphead == NULL) {
        *pphead = newNode;
    }
    else {
        SListNode * tail = *pphead;
        while(tail->next != NULL) {
            tail = tail-> next;
        }
        tail -> next = newNode;
    }
}
//遍历
void SListPrint(SListNode* phead) {
    SListNode * cur = phead;
    while (cur != NULL) {
        printf("%d->",cur->data);
        cur = cur->next;
    }
    printf("NULL\n");
}
```

> 新建`test.c`测试文件

```c
#include "test.h"
int main() {
    SListNode* pList = NULL;
    SListPushBack(&pList,1);
    SListPushBack(&pList,2);
    SListPushBack(&pList,3);
    SListPushBack(&pList,4);
    SListPushBack(&pList,5);
    SListPushBack(&pList,6);
    SListPrint(pList);
   //删除
    SListPopBack(&pList);
    SListPopBack(&pList);
    return 0;
}
```

（2）尾删

```c
//尾删
void SListPopBack(SListNode **pphead){
  //1 NULL
  //2 一个节点
  //3 一个以上节点 
  if (*pphead == NULL) {
    return;
  }
  else if ((*pphead) -> next == NULL) {
    free(*pphead);
    *pphead = NULL;
  }
  else {
    SListNode* prev = NULL;
    SListNode* tail = *pphead;
    while (tail -> next != NULL) {
      prev = tail;
      tail = tail -> next;
    }
    free(tail);
    prev-next = NULL;
  }
}
```

