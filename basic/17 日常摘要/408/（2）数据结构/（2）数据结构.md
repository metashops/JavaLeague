## 一	链表

1、单链表

> 尾插

```c
typedef int SListDataType;
typedef struct SListNode {
  SListDataType data;
  struct SListNode* next;
}SListNode;
SListNode* BuySListNode(SListDataType x) {
  SListNode* newNode = (SListNode*)malloc(sizeof(SListNode));
  if (newNode == NULL) {
    printf("失败。。。\n");
    exit -1;
  }
  newNode->data = x;
  newNode->next = NULL;
  return newNode;
}
void SListPushBack(SListNode** pphead, SListDataType x) {
  SListNode* newNode = BuySListNode(x);
  if (*pphead == NULL) {
    *pphead = NewNode;
  }
  else {
    SListNode* tail = *pphead;
    while (tail->next != NULL) {
      tail= tail->newNode;
    }
    tail->next = newNode;
  }
}
//遍历
void SlistPrint(SListNode* phead) {
  //定义一个cur来存储phead
  SListNode* cur = phead;
  //循环如果链表不为null，就继续打印数据
  while (cur != NULL) {
    printf("%d->",cur->data);
    cur = cur->next;
  }
  printf("NULL\n");
}
```

```c
int main() {
  SListNode* PList = null;//初始化链表
  SListPushBack(&pList,1);//尾插
  SListPushBack(&pList,2);
  SListPushBack(&pList,3);
  SlistPrint(PList);//打印
  SListPopBack(&pList);//删除
  SListPopBack(&pList);
  return 0;
}
```

> 尾删

```c
//尾删
void SListPopBack(SListNode **pphead){
  if (*pphead == NULL) {
    return;
  }
  else if ((*pphead) -> next == NULL) {
    free(*pphead);
    *pphead = NULL;
  }
  else {
    SListNode* prev = NULL;
    SListNode* tail = *pphead;
    while (tail -> next != NULL) {
      prev = tail;
      tail = tail -> next;
    }
    free(tail);
    prev-next = NULL;
  }
}
```



