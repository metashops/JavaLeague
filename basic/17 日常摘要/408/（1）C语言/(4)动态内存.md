## 一、函数

1、变量的作用域和存储方式

* 按作用域分：
  * 全局变量
  * 局部变量
* 按变量的存储方式
  * 静态变量
  * 自动变量
  * 寄存器变量



## 二、指针

#### 1、入门介绍

（1）指针介绍

```c
#include <stdio.h>
int main() {
    //p是变量的名字，int* 表示p变量存放的是int的类型变量的地址
    int *p;
    int i = 3;
    p = &i;//&表示获取地址
    return 0;
}
```

* p = &i;
  * p保存了i的地址，因此p指向i
  * p不是i，i也不是p，更准确的说：修改p的值不影响i的值，修改i也不影响p的值
  * 如果一个指针变量指向了某个普通变量，则*指针变量，就完全等同于，普通变量

> 总结：
>
> * 指针就是地址，地址就是指针
> * 地址就是内存单元的编号
> * 指针变量是存放地址的变量
> * 指针和指针变量是两个不同的概念
> * 但是注意：通常叙述是会把指针变量简称指针，实际含义不同的

（2）什么是地址？

地址：

* 内存单元的编号
* 从零开始的非负整数
* 范围：

指针：

* 指针就是地址，地址就是指针
* 地址就是内存单元的编号
* 指针变量是存放地址的变量
* 指针和指针变量是两个不同的概念
* 但是注意：通常叙述是会把指针变量简称指针，实际含义不同的
* 指针本质就是一个操作 受限的非负整数

#### 2、指针分类

（1）基本类型指针

指针互换

```c
#include <stdio.h>
void swap(int *p, int *q) {
int t;
t = *p;
*p = *q;
*q = t;
}
int main() {
    int a = 100;
    int b= 800;
    swap(&a,&b);
    printf("a=%d,b=%d\n",a,b);
    return 0;
}
```

（2）指针和函数

```c
#include <stdio.h>
void f(int *pArr, int len) {
    int i;
    for (i = 0; i < len; i++)
    {
        printf("%d ",*(pArr+i));
    }
    printf("\n");
    
}
int main() {
    int a[10] = {1,2,3,4,5,6,7,8,9,10};
    f(a,10);
    return 0;
}
```

```c
#include <stdio.h>
void f(int *pArr, int len) {
    pArr[2] = 23;
    for (int i = 0; i < len; i++)
    {
        printf("%d\t",pArr[i]);//*(pArr+i)==*(pArr[i])
    }
    printf("\n");
}
int main() {
    int a[10] = {1,2,3,4,5,6,7,8,9,10};
    printf("%d\n",a[2]);
    f(a,10);
    printf("%d",a[2]);
    return 0;
}
```

（3）动态内存分配

* 传统数组的缺点
  * 数组长度必须事先制定，且只能是常数，不是变量
  * 传统形式定义的数组，该数组的内存程序员无法手动操作，数组一旦定义系统为该数组分配的存储空间就会一直存在，直到该函数运行完毕时，数组的空间才会被系统释放。
  * 数组的长度一旦定义就不能改变。

* 静态内存和动态内存的比较
  * 动态内存解决了静态的的缺陷

（5）Malloc的使用

**注意：malloc 的声明在 stdlib.h 里的**

```c
int *p = (int *)malloc(4);
free(p);
```

解释说明：

* 要使用malloc函数，必须添加 stdlib.h这个头文件
* malloc函数只有一个形参，并且形参时整型的
* malloc(4)表示请求系统为本程序分配4个字节
* malloc函数只能返回第一个字节的地址
* p本身所占的内存时静态分配的，p所指向的内存时动态分配的
* Free(p)表示把p所指向的内存 给释放掉

