## 一、中国邮递员问题（CPP）

![E8AC6D6A-5FC7-4A3C-8564-8F125CEADF72.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gqvsboliekj60zk0ex75v02.jpg)



![7C888DE8-04EA-4E9E-AE7B-C7CAE9181DB6.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gqvsd3u679j60zk0i1wj502.jpg)

（1）建立（model）

```ampl
set node;
set road within node cross node;
param cost{road};
var X{(i,j)in road}binary;
minimize TC:sum{(i,j)in road}cost[i,j]*X[i,j];
subject to link{(i,j) in road}:X[i,j]+X[j,i]>=1;
subject to node2{k in node}:
sum{(i,k) in road}X[i,k]=sum{(k,j)in road}X[k,j];
```

（2）数据（data）

```ampl
set node:=0 1 2 3 4 5 6 7 8;
set road:=
(0,1),(1,0),(0,2),(2,0),
(1,4),(4,1),(1,2),(2,1),
(4,5),(5,4),(4,3),(3,4),
(2,3),(3,2),(2,7),(7,2),
(5,6),(6,5),(6,3),(3,6),
(6,7),(7,6),(6,8),(8,6),
(8,7),(7,8);
param:cost:=
0 1 4
1 0 4
0 2 4
2 0 4
1 2 6
2 1 6
1 4 7
4 1 7
2 3 6
3 2 6
2 7 10
7 2 10
3 4 7
4 3 7
3 6 3
6 3 3
4 5 4
5 4 4
5 6 4
6 5 4
6 7 7
7 6 7
6 8 7
8 6 7
7 8 4
8 7 4;
```

（3）运行

运行model and data文件

```ampl
#1、先运行reset命令
reset;
#2、再运行
model cpp.mod;data cpp.dat;
#3、
solve；
#4、
option solver cplex;
#5、
solve;
#6、显示如下
display X;
X [*,*]
:   0   1   2   3   4   5   6   7   8    :=
0   .   0   1   .   .   .   .   .   .
1   1   .   0   .   1   .   .   .   .
2   0   1   .   0   .   .   .   1   .
3   .   .   1   .   0   .   1   .   .
4   .   1   .   1   .   0   .   .   .
5   .   .   .   .   1   .   0   .   .
6   .   .   .   1   .   1   .   1   0
7   .   .   0   .   .   .   1   .   1
8   .   .   .   .   .   .   1   0   .
;

```



二、最小生成树问题

![A635FF81-A10F-4DF2-814E-20B8D96A928E.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gqvt4p43zlj60rh0k0n0002.jpg)

![136C4529-A270-4732-AE59-C09B272ED0E3.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gqvt56kqq1j60qp0k0ju802.jpg)

model

```ampl
param n;
param start;
param end;
param M=999999;
param d{i in 1..n,j in 1..n}default M;
param rhs{i in 1..n}=if i=start then 1
                     else (if i=end then -1 else 0);
       var x{i in 1..n,j in 1..n}>=0;
       var outFlow{i in 1..n}=sum{j in 1..n}x[i,j];
       var inFlow{j in 1..n}=sum{i in 1..n}x[i,j];
minimize z:sum{i in 1..n,j in 1..n}d[i,j]*x[i,j];
subject to limit{i in 1..n}:outFlow[i]-inFlow[i]=rhs[i];
```

data

```ampl
param n :=6;
param start:=1;
param end:=6;
param d:
  1  2   3   4   5  6:=
1 .  4    6   .   .  .
2 .  .    .   5  4   .
3 .  .    .   4   7  .
4 .  .    .   .   5   7
5 .  .    .   .   .    5;
```



