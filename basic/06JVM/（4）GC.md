

## GC 篇

### GC 简介

> 1、什么是垃圾？

垃圾就是在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能内存溢出。

> 2、为什么需要GC？

* 因为不断地进行分配内存空间，如果不进行GC回收，内存可能可快会被消耗完。
* 释放没有用的对象以及清楚内存里的记录碎片。
* 如果不进行GC回收，那么在业务越来越复杂的时候，会造成STW的GC，所以需要不断尝试对GC进行优化。

> 内存泄漏：垃圾对象无法被清除，导致内存不断被占用，直到出现内存溢出，从而造成程序崩溃。



### 垃圾回收相关算法

> 1、对象存活判断

（1）引用计数算法：对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。

优点：判断效率高，回收没有延迟

缺点：需要单独的字段存储计数器这样增加空间的开销；每次赋值需要更新计数器这样会增加时间开销；还有就是引用计数器有一个严重的问题，**无法处理循环引用**情况。

（2）可达性分析算法：有效解决在引用计数算法中循环引用的问题，防止内存泄漏发生。

原理：可达性分析是以根对象集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。如果对象没有任何引用链（Reference Chain）相连，则可以标记为垃圾对象。

GC Roots包括以下几个类：

* 虚拟机栈中引用的对象
* 本地方法栈
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 所有被同步锁synchronize持有的对象
* 临时性的加入：比如，分代收集和局部回收（Partial GC）

注意：

* 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。如果这一点不能满足的话分析结果的准确性就无法保证
* 这一点也是导致GC进行时必须“Stop The World”的一个重要原因（即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的）

> Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。
>
> 停顿的原因:



> 2、使用MAT查看GC ROOTS

> MAT是Memory Analyze的简称。

生成dump文件

* 方式一：使用命令行jmap
* 方式二：使用JVisualVM导出



> 4、垃圾收集算法

（1）标记-清除算法（Mark Sweep）

当堆中有效内存空间被耗尽时候，就会停止整个程序（也称为Stop The World），然后进行两项工作第一就是标记，第二就是清除。

标记：collector从引用根节点开始遍历，标记所有被引用对象。（也就是说，标记非垃圾的对象，剩余没有被标记的就进行垃圾回收）

清除：collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收。

缺点：

* 执行效率稳定
* 在进行GC时候，需要停顿整个引用程序，这样导致用户体验差
* 清除后会产生不连续内存碎片，如果需要分配大对象时无法找到足够连续内存，则会再次出发垃圾收集动作。

（2）标记-复制算法（Mark Copying）

原理：把可用内存空间分成两块，每次只用其中一块，将存活的对象复制到另一块，然后再把已经使用过的内存空间清除掉。

优点：运行效率高；不会出现“碎片”问题

缺点：将原来内存缩小为一半，这样会出现空间浪费的问题。

使用场景：在新生代，对常规应用的垃圾回收，一次可以通过回收70%-99%的内存空间。回收性价比很高，所以现在商业虚拟机都是使用这个收集算法回收新生代。

（3）标记-整理算法/压缩算法（Mark Compact）

执行过程：首先标记所有被引用对象；然后将所有的存活对象压缩到内存一端按顺序排放；最终清除边界所有空间。

优点：解决标记-清除算法中的内存区域分散问题以及解决复制算法中的内存空间缩小一半的问题。

缺点：

* 效率低于标记-复制算法
* 移动过程需要暂停用户程序（STW）

### 三种算法总结

* 从效率上，标记-复制算法执行效率最高的，但是浪费了点内存空间；
* 从整体来看，标记-整理算法相对平滑一些，但效率又不行。



### 到底使用那个算法才效率高？

> 没有最好的，只有更合适的，具体问题，具体分析。
>
> 目前几乎所有GC都是采用分代收集算法执行垃圾回收

* 年轻代（Young GC）：年轻代对象生命周期短、存活率很低，而且回收频繁，适合使用标记-复制算法，效率高，该算法的效率只和当前对象存活大小有关。
* 老年代（Tenured Gen）：特点区域大，对象生命周期长，存活率高，回收不怎么频繁。所以适合使用标记-清除算法或者和标记-整理算法混合使用。



### 垃圾回收相关概念的概述

> 1、你是如何理解 System.gc()的？

默认情况下，通过system.gc() 或 Runtime.getRuntime().gc() 的调用，会显示触发Full GC，同时对老年代和新生代进行回收，尝试释放被爹丢弃对象占用的内存。但是system.gc() 不一定会立刻执行，所以无法保证垃圾收集器的调用。

```java
public class GCtest01 {
    public static void main(String[] args) {
        new GCtest01();
        System.gc();//提醒JVM垃圾回收器执行GC（注：不一定马上执行）
        System.runFinalization();//调用runFinalization()才能强制调用GC
    }
    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("GCtest01 重写finalize");
    }
}
```

> 2、内存溢出（OOM）

堆空间不足原因：

* Java虚拟机的堆空间设置不够
  * 通过 -Xms、Xmx 来设置合适的参数
* 代码中创建大量对象，并且长时间不能被垃圾收集器收集

> 3、你理解内存泄漏(Memory Leak)吗？

（1）存在很多垃圾对象，但又无法被GC回收的情况会出现内存泄漏

（2）出现内存泄漏不会立即使程序崩溃，要等到内存被使用完，最终出现OOM异常。(注：内存泄漏不一定发生OOM)

> 4、知道 STW 吗？什么时候发生 STW 呢？

（1）STW 全称 “Stop The World”，是指在 GC 事件发生过程中，会产生引用程序的停顿，有点像卡死的感觉。

（2）可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。所以在分析时要确保一致性的快照中进行，这样分析结果准确，否则就在对象引用关系还在不断变化分析就无法保证准确性。

（3）被STW中断的引用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡顿，所以应该减少 STW 发生。

（4）开发中不要主动去调用 System.gc() ，会导致 Stop The World 的发生。



> 5、并发（Concurrent） 和 并行（Parallel）

并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到完毕之间，且这几个程序都是同一个处理器上运行的。

并行：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。

总结：

* 并发：是指多个程序，在同一时间段内同时发生
* 并行：是指多个程序，在同一时间点上同时发生

> 垃圾回收的并发与并行

* 并行（Parallel）：是指多条垃圾收集线程并行工作。
  * 如： parNew、Parallel scavenge、parallel old
* 并发（Concurrent）：指用户线程和垃圾收集线程同时执行，垃圾回收线程在执行不会停顿用户程序的运行
  * 如： CMS 、 G1
* 串行（serial）：单线程执行的，如果内存不够则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。



### 引用

> 面试题：强引用、软引用、弱引用、虚引用的区别？

强引用：是最传统的“引用”定义，是指在程序代码之中普遍存在的引用赋值，类似“Object obj = new Object()”这种引用关系，无论任何情况下只用强引用关系还在，垃圾收集器永远不会回收掉发被引用的对象。（反正只要通过new关键都是强引用）所以强引用可能会造成内存泄漏问题。（不回收）

软引用：是指用来描述一些还有用的对象但是不是必要的对象，它只关注软引用关联的对象，在系统要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收。（内存不足就回收）

弱引用：比软引用还要弱一点引用，它只被弱引用关联的对象只能生存到下一次垃圾收集发生为止，在系统GC时，只要发现弱引用，不管系统系统维护空间使用时是否充足，都会回收掉只被弱引用关联的对象。（发现即回收）

虚引用：是所有引用中最弱的一个，弱到一个对象是否有虚引用的存在，完全不会决定对象的生命周期，随时都可以被垃圾回收器回收。（对象回收跟踪）