### 第一章	了解

1、JVM的位置

从最底层到应用层：硬件 -->操作系统（如：Linux）--> JVM --> 字节码文件 --> user，JVM是运行在操作系统上的，与硬件没有直接互交。

2、Java代码执行流程

Java源码 ---> Java编译器(词法分析-->语法分析-->语法抽象语法树-->语义分析-->注解抽象语法树-->字节码生成器) --> 字节码文件 -->Java虚拟机（ 类加载器 --> 字节码校验器 --> 翻译字节码和JIT编译器）--> 操作系统

3、JVM发展历程

* 1996年Java1.0版本的时候，sun公司发布一款名为sun classicVM的Java虚拟机，这款虚拟机只提供解释器。

* hotspot 从服务器、桌面到移动端、嵌入式都有应用

* BEA的JRockit，该虚拟机专注服务器端应用

* IBM的J9，该虚拟机与hotspot接近，服务器端、桌面应用、嵌入式等多用途VM



### 第二章	类加载子系统

#### 1、类加载过程

一个类从被加载到虚拟机内存，再到卸载出内存这样的整个生命周期需要经历5个阶段：

加载(loading) --> 连接(Linking) --> 初始化(Initialization) --> 使用(Using) --> 卸载(Unloading) ，这就是类的生命周期。其中，连接又分为三个阶段：验证(Verification) --> 准备(Preparation) --> 解析(Resolution)，下面我们依次展开每个过程。

#### 加载

在加载阶段，Java虚拟机需要完成以下三个事情：

（1）通过一个类的全限定名获取定义此类的二进制字节流

（2）将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**

（3）在内存生成一个代表这个类的java.lang.class对象，作为方法区这个类的各个数据访问入口

#### 连接

（1）验证(Verify)

目的就是确定Class文件的字节流中包含的信息是否符合《Java虚拟机规范》，保证运行后不会危害虚拟机自身安全。验证大致完成四个阶段的验证动作：文件格式验证、元数据验证、字节验证和符号引用验证。

（2）准备(Prepare)

* 准备阶段是仅为**类变量**分配内存，并且设置该类变量的默认初始值，初始值为零，比如我们代码定义一个类变量：

```java
public static int value = 1;
```

意思是指在准备阶段，value值是为零的，要到初始化阶段才被赋值为1。

* 但不包括final修饰static及不包括实例变量，final在编译时就分配，实例变量会随着对象一起分配到Java堆中。

（3）解析(Resolve)

将常量池内的符号引用转换为直接引用的过程，这个阶段通常在执行完初始化之后再执行的。

符号引用就是一组符号来描述引用的目标；直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。

#### 初始化

#### 2、你知道双亲委派机制吗？

> 类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开始，类加载过程采用双亲委派机制，这样机制能更好地保证Java平台的安全。

##### 什么使用双亲委派机制？

为了避免类的重复加载以及保护程序安全，防止核心API被随意更改。

缺点：顶层的classLoader无法访问底层的classLoader所加载的类

##### 原理

就是一个类加载器收到请求时，它不会自己去尝试加载类，而是把请求委托给父类加载器去完成，依次递归，如果父类加载可以完成类加载任务就返回成功，如果父类加载器无法加载时才自己去加载。



**沙箱安全机制**：就是在加载自定义类的时候会率先使用引导类加载器加载，它是起到保证对Java 核心源代码的保护功能。

##### 打破双亲委派机制是什么意思？

只要加载类时候，不是从应用程序类加载-->扩展类加载器-->启动类加载器这样的顺序就算打破了。因为加载class核心方法是在loaderclass类的loadclass方法上的，只要自定义classloader，重写loadclass方法，那就算打破双亲委派机制了吧。



**双亲委派模型主要出现过三次较大规模的“被破坏”情况**

双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前--即JDK1.2发布之前。

双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。

双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。

### 第三章	运行时数据区

#### 一、程序计数器（PC寄存器）

PC寄存器用来存储将要执行的下一条指令的地址，然后由执行引擎读取下一条指令。PC寄存器也是用来记录当前线程执行的地址。是唯一没有规定任何OOM情况。

> 方法区和堆是有GC的，而栈和PC寄存器及本地方法没有GC，但栈可能出现内存溢出问题。

例子：

```
javap -verbose xxx
```

![WeChat487798d24c535a3652d6f788e40ff238.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gt8a61i26fj60zy0jqqap02.jpg)

#### 面试

##### 使用PC寄存器存储字节码指令地址有什么？

> JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

##### 为什么使用PC寄存器记录当前线程的执行地址？

> 因为CPU需要不停切换各个线程，这时候切换回来以后，就得知道接着从哪里开始继续执行

#### 二、虚拟机栈

##### 1、概念

每个线程在创建时都会创建一个虚拟机栈，也称为栈帧 (Stack Frame)用于存储**局部变量表、操作数栈**、动态链接、方法返回地址以及一些附加信息。是线程私有的，生命周期和线程一致。

值得注意的是：栈是不存在GC问题的，但是出现栈溢出问题。

面试题：开发中遇到的异常有哪些？内存溢出；OOM异常

> 该区两类异常：如果线程请求的栈深度大于虚拟机所允许的深度（抛出stackOverFlowError异常）；如果Java虚拟机栈容量是动态扩展的，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。



##### 2、静态变量和局部变量

变量的分类：

* 按照数据类型分：基本数据类型和应用数据类型
* 按照在类中声明位置分：
  * 成员变量：
    * 类变量：在连接和准备阶段给类变量默认赋值
    * 实例变量：随着对象创建，会在堆空间中分配实例变量空，并进行默认赋值
  * 局部变量：在使用前，必须进行赋值否则编译不通过如下：

![WeChatd3c85827436b8265b7e6361fe9f8d9df.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gtaj40ap18j30w208ygnm.jpg)

3、局部变量表

局部变量表（local variable table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量是以变量槽为最小单位。

4、操作数栈（operand stack）

操作数栈主要是用来保存过程中间结果，同时作为计算过程中变量临时的存储空间；操作数栈是JVM执行引擎的一个工作区。

![WeChata17dc30e95f70178b6059a55d9ac6c66.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gtajlzh4wnj30rk0coace.jpg)

Load_.存放在局部变量表中

5、动态链接

每个栈桢内部都包含一个指向运行时常量池中该栈桢所属方法的应用。在Java源文件被编译到字节码中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中。

![WeChatf4c352fccae9dbd1e56f4b4e0c45c8dd.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gtakqpifd8j315k0o4grh.jpg)

常量池的目的就是为了提供一些符号和常量，便于指令的识别。

6、方法的调用

JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

符号引用转换直接引用的转换过程是在编译期间确定还是在运行期间确定下来？

* 静态链接：如果被调用的目标方法在编译期可知，则是在静态链接确定的
* 动态链接：如果被调用的方法在编译期无法被确定下来，只能在运行期确定的则称为动态链接

7、方法返回值

存放调用该方法的PC寄存器的值，一个方法的结束有两种方式：正在执行完成和出现未处理的异常也就是非正常退出。

8、一些附加信息

9、面试题

（1）栈溢出错误有哪些？

stackoverflowerror；当整个空间不足了，栈再扩容时就出现OOM

（2）调整栈大小就能保证不出现溢出吗？

不能，只能暂时保证但后来就不一定啦

（3）分配的栈内存越大越好吗？

理论上越大的话就避免出现溢出问题，但是可能某时候就出现溢出，空间是有限的并不能越大越好。

（4）垃圾回收是否会涉及到虚拟机栈？

PC计数器和虚拟机栈都不出现GC问题，只有方法区和堆存在GC和error

（5）方法定义的局部变量是否线程安全？

这个得具体问题具体分析。比如定义StringBuffer本身就是安全那就是安全啦，但是StringBuilder就不安全。

#### 三、本地方法栈

Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用，也是线程私有的。

如果线程请求份哦的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出stackoverflowError异常

如果本地方法栈可以动态扩展，且在尝试扩展的时候无法申请到足够的内存，或者在创建新线程时没有足够的内存去创建对应的本地方法栈，此时Java虚拟机抛出OutOfMemoryError异常





## 堆（Heap）篇

#### 1、概念

一个JVM实例只存在一个堆，Java堆区在启动JVM时即被创建，其空间大小也就确定了，但可以通过参数进行调整空间大小。

是所有线程共享的一块内存区域，是“几乎”所有的对象实例分配内存的区域。

#### 2、堆结构

Java堆是垃圾收集器管理的内存区域，也被称作“GC堆”。现代垃圾收集器大部分都是基于分代收集理论设计，细分为：

Java7及之前堆内存逻辑分为：新生代、老年代及永久代

Java8及之后分为：新生区、来老年区及元空间

#### 3、设置堆内存大小与OOM

Java堆（年轻区和老年区）是用于存储Java对象实例，大小可以通过参数进行设置

```java
-Xms #用于表示堆区起始内存
-Xmx #表示堆区最大内存
```

一旦堆区中内存大小超过“-Xmx“所指定的最大内存时将会抛出OOM异常，

查看设置的参数：方式一

```
jps
jstat -gc 进程ID
```

方式二：-XX：+ PrintGCDetails

可视化工具：自带的jconsole

#### 4、年轻代和老年代

Java堆区进一步细分分分为：年轻代（YoungGan）和老年代（OldGen），其中年轻代可以划分为：Eden空间、survivor0 空间和 survivor1空间。

#### 5、对象分配过程

（1）new的对象先放在eden区，当Eden满时JVM的垃圾回收起将对Eden进行垃圾回收，将不再被其他对象所用的对象进行销毁。

（2）然后Eden区中的剩余对象移动到幸存者S0区

（3）如果再次触发垃圾回收，此时上次幸存者下来的放到幸存者S0区，如果没有回收就会放到幸存者S1区

（4）如果再次经历垃圾回收，此时会重新放回幸存者S0区，接着再去幸存者1区

（5）啥时候区养老区？可以设置次数，默认15次

```
-XX:MaxTenuringThreshold=<N>
```

总结：

关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。

#### 6、常用优化工具

JDK命令行、Jconsole、VisualVM、Jprofiler、Java Flight Recorder、GCViewer、GC Easy

#### 7、Minor GC、Major GC 及Full GC的对比

（1）针对hotspot VM的实现，它里面的GC按照回收区域又分为两大类型：部分收集（Partial GC）和整堆收集（Full GC）

**部分收集**：不是完整收集整个Java堆垃圾收集，其中又分为：

* 新生代收集（MinorGC/YoungGC）：只是新生代（Eden和S0，S1）的垃圾收集

* 老年代收集（MajorGC/OldGC）：只是老年区代垃圾收集。
  * 目前只有CMS GC会单独收集老年代的行为。
  * 注意：很多时候MajorGC会和FullGC混淆使用，需要具体分辨是老年代回收还是正堆回收

* 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集
  * 目前石油G1GC会有这种行为

**整堆收集（FullGC）**：收集整个Java堆和方法区垃圾收集

（2）年轻代GC（MinorGC）触发机制

* 当年轻代空间不足时就会触发MinorGC，这里的年轻代满指的是Eden代满，survive满不会触发GC

* 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

* Minor GC会引发 STW，暂停其他用户线程等垃圾回收结束，用户线程才会恢复运行。

（3）老年代GC（MajorGC/FullGC）触发机制

* 当老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC

* Major GC 的速度比MinorGC慢10陪以上，导致STW的时间更长

* 如果Major GC后内存还不足，就报OOM

（4）FullGC（后面细讲）

* 触发Full GC执行的情况有如下五种：
  * 调用system.gc() 时，系统建议执行Full GC，但不是必然执行
  * 老年代空间不足
  * 方法区空间不足
  * 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  * 由Eden区、survivor space 0（From space）区向survivor space1（To space）区复制时，对象大小大于Tospace可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

说明：Full GC 是开发或调优中尽量避免的

GC举例及日志分析

源码：

```java
import java.util.ArrayList;

public class GCTest {
    public static void main(String[] args) {
        int i = 0;
        try {
            ArrayList<String> list = new ArrayList<>();
            String str = "cathax";
            while (true) {
                list.add(str);
                str = str + str;
                i++;
            }
        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println("遍历次数：" + i);
        }
    }
}

```

参数设置：

```
-Xms9m -Xmx9m -XX:+PrintGCDetails
```

#### 8、对象分配过程：TLAB

堆区是线程共享区域，任何线程 都可以访问到堆中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在开发环境下堆区 中划分内存空间是线程不安全的，为了避免多个线程操作同一个地址，需要使用加锁等机制，进二影响分配速度。

#### 9、总结：堆空间的参数设置

```
-Xms：初始化堆空间
-Xmx：最大堆空间内存
-Xmn：设置新生代的大小
-XX:NewRatio：设置新生代与老年代在堆结构的占比
-XX:SurvivorRatio：设置新生代中Eden区和S0/S1空间比例
-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
-XX:+PrintGGCDetails：输出详细的GC处理日志
-XX:+PrintGC：打印GC简要信息
-verbose:gc：打印GC简要信息
-XX:HandlePromotionFailure：是否设置空间分配担保
```

10、堆空间分代思想

堆分代目的优化GC性能，



## 方法区篇

##### 1、栈、堆、方法区的交互关系

![141628847214_.pic_hd.jpg](http://ww1.sinaimg.cn/large/006FuVcvgy1gtfanpjppxj318n0kyadq.jpg)

```java
Person person = new Person();
Person存放方法区
person存放栈
new Person()存放Java堆中
```

##### 2、方法区的理解

方法区与Java堆一样都是各个线程共享的内存区域，方法区在JVM启动时候被创建，并且它的实际的物理内存空间中和 Java堆区一样都可以是不连续的，空间大小可以选择固定或者可扩展的。

方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机会抛出溢出异常。

##### 3、HostPot中方法区的演进

在JDK7及以前习惯把方法区称为永久代，到JDK8开始使用元空间取代了永久代了

##### 4、设置方法区大小与OOM

JDK 7及以前：

通过-XX:PermSize来设置永久代初始分配空间，默认值是20.75M

-XX:MaxPermSize来设置永久代最大可分配空间，32位机器默认是64M，64位机器默认是82M

如果JVM加载的类信息容量超过了这个值会抛出OOM:PermGen space

JDK8开始

元数据大小可以使用参数-XX:Metaspacesize和-XX:MaxMetaspaceSize指定代替JDK7及之前的参数

```
-XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m 
```

##### 5、举例方法区OOM异常

##### 6、如何解决OOM

（1）通过内存映像分析工具对DUMP出来的堆转储快照进行分析，分析到底是内存泄露（Memory Leak）还是内存溢出（Memory OverFlow）

（2）如果是内存泄露，我们可以通过工具查看泄漏对象到GC Roots的引用链，这样可以找到泄漏的对象是怎么样的路径与GC Roots相关联导致垃圾收集器无法自动回收。

（3）如果不存在内存泄漏，内存中的对象确实还必须存活着，那就检查堆参数（-Xmx 与 -Xms）

##### 7、方法区内部结构

方法区主要存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓冲等。

常量池中有：数量值、字符串值、类引用、字段引用、方法引用

> 运行时常量池：是方法区的一部分
>
> 常量池是class文件的一部分，用于存放编译期生成的各种字面亮与符号引用，这部分内容将在类加载放到方法区的运行时常量池中。



##### 8、JDK7 、JDK8的区别

Hotspot虚拟机中方法区的变化：

JDK6及之前，有永久代（Permanent generation），静态变量存放在永久代上

JDK7有永久代，但是已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中

JDK8及之后，没用永久代、类型信息、字段、方法区、常量保存在本地内存的元空间，但是负资产常量池、静态变量仍在堆中

##### 9、永久代为什么换成元空间？

在某种场景下，如果动态加载类过多，就很容易产生Perm区的OOM，就比如Web工程因为功能点比较多，在运行时要不断动态加载很多类，这样就容易出现OOM。元空间和永久代之间最大区别是：元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制。还有永久代调优比较困难，空间大小很难确定。

##### 10、方法区的垃圾收集

方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型



### 对象的创建过程

#### 对象创建步骤：

1. 判断对象对应的类是否加载、链接、初始化：当我们通过new对象，它首先查看这个指令的参数能否在metaSpace的常量池中定位到一个类的引用符号，且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有加载那么就在双亲委派模式下使用当前类加载器以classLoader+包名+类名为Key进行查找对应的class文件，如果没有找到文件会抛出classNotFountException异常，如果找到则进行加载并生成对应class类对象。
2. 为对象分配内存
3. 处理并发安全问题（因为堆是共享的，所有可能会出现并发问题）：采取CAS失败重试，区域加锁保证更新的原子性 和 每个线程预分配一块TLAB-通过`-XX:+/-UseTLAB`参数来设定。
4. 初始化分配到的空间：所有属性默认值，保证对象实例字段在不赋值是可以直接使用
5. 设置对象的对象头：就是将对象的hashCode和对象 GC信息、锁信息等数据存储在对象头
6. 执行init方法进行初始化

简介步骤：

>1、加载类元信息；2、为对象分配内存；3、处理并发问题；4、属性默认初始化；5、设置对象头信息；6、属性显示初始化、代码块中初始化、构造器初始化

#### 对象在堆中内存布局

* 对象头（header）:
  * 运行时元数据（Mark Word）：包括哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
  * 类型指针：指向类元数据instanceKlass，确定改对象所属的类型

* 实例数据（Instance Data）
* 对齐填充



对象访问定位

JVM是如何通过栈桢中的对象引用访问到其内部的对象实例？





## String 篇

### 1	String的基本特性

string：字符串，使用一对双引号表示

```
string s1 = "hello";
string s2 = new string("hello");
```

String 声明为final的，不可被继承

String 实现了Serializable接口：表示字符串是支持序列化，实现了Comparable接口：表示String可以比较大小

String在JDK8及以前内部定义了final char[] value用于存储字符串数据，JDK9时改为byte[]

### 2、String的内存分配

直接使用双引号声明出来的string对象会直接存储在常量池中

```
string s1 = "hello string";
```

如果不是使用双引号声明的string对象，可以使用string提供的intern()方法

Java 6及以前，字符串常量池存放在永久代

Java7中将字符串常量池的位置调整到Java堆中

* 所有的字符串都保存在堆中，和其他普通对象一样，这样可以让你在进行调优引用是仅需要调整堆大小就可以
* 字符串常量池概念使用的比较多，但是这个改动使得我们有足够的理由让我们重写考虑在Java7使用string.intern()。

Java 8 元空间，字符串常量在堆

可以调整堆大小

```java
-XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m
```

### 3、字符串拼接操作

* 常量与常量的拼接结果在常量池，原理是编译期优化
* 常量池中不会存放相同的内容常量
* 只要其中一个是变量，结果就在堆中，变量拼接的原理是stringBuilder
* 如果拼接的结果调用intern方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象

![WeChat9493e044731eb378f3ed210f11b3217e.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gtmg5xb9e1j32q612ktse.jpg)



### 4、intern()的使用

官方注解：

```java
/**
     * Returns a canonical representation for the string object.
     * <p>
     * A pool of strings, initially empty, is maintained privately by the
     * class {@code String}.
     * <p>
     * When the intern method is invoked, if the pool already contains a
     * string equal to this {@code String} object as determined by
     * the {@link #equals(Object)} method, then the string from the pool is
     * returned. Otherwise, this {@code String} object is added to the
     * pool and a reference to this {@code String} object is returned.
     * <p>
     * It follows that for any two strings {@code s} and {@code t},
     * {@code s.intern() == t.intern()} is {@code true}
     * if and only if {@code s.equals(t)} is {@code true}.
     * <p>
     * All literal strings and string-valued constant expressions are
     * interned. String literals are defined in section 3.10.5 of the
     * <cite>The Java&trade; Language Specification</cite>.
     *
     * @return  a string that has the same contents as this string, but is
     *          guaranteed to be from a pool of unique strings.
     * @jls 3.10.5 String Literals
     */
    public native String intern();
```

面试题：new String("ab")会创建几个对象？

一个对象是new关键字在堆空间创建

另一个对象是：字符串常量池中的对象，可以通过字节码指令：ldc

```java
 Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String       //new在堆中
         3: dup
         4: ldc           #3                  // String ab                    //ab在常量池中
         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V   //构造器初始化
         9: astore_1                                                          //得到对象赋给str，放入局部变量表
        10: return

```

面试题：new String("a") + new String("b")会创建几个对象？在常量池不存在ab的

JDK6以前有5个对象

JDK7以后有4个对象

```java
public class StringTest05 {
    public static void main(String[] args) {
        //String str = new String("ab");
        //String s1 = "ab";
        //执行这行代码字符串常量池不会存在"ab"
        String str = new String("a") + new String("b");
        str.intern();//在字符串常量池中生成"ab"(JDK7没有创建常量池ab而是创建一个指向堆空间对象，JDK6创建了一个对象ab)
        String s1 = "ab";//s4变量记录的地址使用上一行的代码执行是在常量池生成的"ab"
        System.out.println(s1==str);
    }
}

```





## GC 篇

### GC 简介

> 1、什么是垃圾？

垃圾就是在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能内存溢出。

> 2、为什么需要GC？

* 因为不断地进行分配内存空间，如果不进行GC回收，内存可能可快会被消耗完。
* 释放没有用的对象以及清楚内存里的记录碎片。
* 如果不进行GC回收，那么在业务越来越复杂的时候，会造成STW的GC，所以需要不断尝试对GC进行优化。

> 内存泄漏：垃圾对象无法被清除，导致内存不断被占用，直到出现内存溢出，从而造成程序崩溃。



### 垃圾回收相关算法

> 1、对象存活判断

（1）引用计数算法：对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。

优点：判断效率高，回收没有延迟

缺点：需要单独的字段存储计数器这样增加空间的开销；每次赋值需要更新计数器这样会增加时间开销；还有就是引用计数器有一个严重的问题，**无法处理循环引用**情况。

（2）可达性分析算法：有效解决在引用计数算法中循环引用的问题，防止内存泄漏发生。

原理：可达性分析是以根对象集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。如果对象没有任何引用链（Reference Chain）相连，则可以标记为垃圾对象。

GC Roots包括以下几个类：

* 虚拟机栈中引用的对象
* 本地方法栈
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 所有被同步锁synchronize持有的对象
* 临时性的加入：比如，分代收集和局部回收（Partial GC）

注意：

* 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。如果这一点不能满足的话分析结果的准确性就无法保证
* 这一点也是导致GC进行时必须“Stop The World”的一个重要原因（即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的）

> Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。
>
> 停顿的原因:



> 2、使用MAT查看GC ROOTS

> MAT是Memory Analyze的简称。

生成dump文件

* 方式一：使用命令行jmap
* 方式二：使用JVisualVM导出



> 4、垃圾收集算法

（1）标记-清除算法（Mark Sweep）

当堆中有效内存空间被耗尽时候，就会停止整个程序（也称为Stop The World），然后进行两项工作第一就是标记，第二就是清除。

标记：collector从引用根节点开始遍历，标记所有被引用对象。（也就是说，标记非垃圾的对象，剩余没有被标记的就进行垃圾回收）

清除：collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收。

缺点：

* 执行效率稳定
* 在进行GC时候，需要停顿整个引用程序，这样导致用户体验差
* 清除后会产生不连续内存碎片，如果需要分配大对象时无法找到足够连续内存，则会再次出发垃圾收集动作。

（2）标记-复制算法（Mark Copying）

原理：把可用内存空间分成两块，每次只用其中一块，将存活的对象复制到另一块，然后再把已经使用过的内存空间清除掉。

优点：运行效率高；不会出现“碎片”问题

缺点：将原来内存缩小为一半，这样会出现空间浪费的问题。

使用场景：在新生代，对常规应用的垃圾回收，一次可以通过回收70%-99%的内存空间。回收性价比很高，所以现在商业虚拟机都是使用这个收集算法回收新生代。

（3）标记-整理算法/压缩算法（Mark Compact）

执行过程：首先标记所有被引用对象；然后将所有的存活对象压缩到内存一端按顺序排放；最终清除边界所有空间。

优点：解决标记-清除算法中的内存区域分散问题以及解决复制算法中的内存空间缩小一半的问题。

缺点：

* 效率低于标记-复制算法
* 移动过程需要暂停用户程序（STW）

### 三种算法总结

* 从效率上，标记-复制算法执行效率最高的，但是浪费了点内存空间；
* 从整体来看，标记-整理算法相对平滑一些，但效率又不行。



### 到底使用那个算法才效率高？

> 没有最好的，只有更合适的，具体问题，具体分析。
>
> 目前几乎所有GC都是采用分代收集算法执行垃圾回收

* 年轻代（Young GC）：年轻代对象生命周期短、存活率很低，而且回收频繁，适合使用标记-复制算法，效率高，该算法的效率只和当前对象存活大小有关。
* 老年代（Tenured Gen）：特点区域大，对象生命周期长，存活率高，回收不怎么频繁。所以适合使用标记-清除算法或者和标记-整理算法混合使用。



### 垃圾回收相关概念的概述

> 1、你是如何理解 System.gc()的？

默认情况下，通过system.gc() 或 Runtime.getRuntime().gc() 的调用，会显示触发Full GC，同时对老年代和新生代进行回收，尝试释放被爹丢弃对象占用的内存。但是system.gc() 不一定会立刻执行，所以无法保证垃圾收集器的调用。

```java
public class GCtest01 {
    public static void main(String[] args) {
        new GCtest01();
        System.gc();//提醒JVM垃圾回收器执行GC（注：不一定马上执行）
        System.runFinalization();//调用runFinalization()才能强制调用GC
    }
    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("GCtest01 重写finalize");
    }
}
```

> 2、内存溢出（OOM）

堆空间不足原因：

* Java虚拟机的堆空间设置不够
  * 通过 -Xms、Xmx 来设置合适的参数
* 代码中创建大量对象，并且长时间不能被垃圾收集器收集

> 3、你理解内存泄漏(Memory Leak)吗？

（1）存在很多垃圾对象，但又无法被GC回收的情况会出现内存泄漏

（2）出现内存泄漏不会立即使程序崩溃，要等到内存被使用完，最终出现OOM异常。(注：内存泄漏不一定发生OOM)

> 4、知道 STW 吗？什么时候发生 STW 呢？

（1）STW 全称 “Stop The World”，是指在 GC 事件发生过程中，会产生引用程序的停顿，有点像卡死的感觉。

（2）可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。所以在分析时要确保一致性的快照中进行，这样分析结果准确，否则就在对象引用关系还在不断变化分析就无法保证准确性。

（3）被STW中断的引用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡顿，所以应该减少 STW 发生。

（4）开发中不要主动去调用 System.gc() ，会导致 Stop The World 的发生。



> 5、并发（Concurrent） 和 并行（Parallel）

并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到完毕之间，且这几个程序都是同一个处理器上运行的。

并行：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。

总结：

* 并发：是指多个程序，在同一时间段内同时发生
* 并行：是指多个程序，在同一时间点上同时发生

> 垃圾回收的并发与并行

* 并行（Parallel）：是指多条垃圾收集线程并行工作。
  * 如： parNew、Parallel scavenge、parallel old
* 并发（Concurrent）：指用户线程和垃圾收集线程同时执行，垃圾回收线程在执行不会停顿用户程序的运行
  * 如： CMS 、 G1
* 串行（serial）：单线程执行的，如果内存不够则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。



### 引用

> 面试题：强引用、软引用、弱引用、虚引用的区别？

强引用：是最传统的“引用”定义，是指在程序代码之中普遍存在的引用赋值，类似“Object obj = new Object()”这种引用关系，无论任何情况下只用强引用关系还在，垃圾收集器永远不会回收掉发被引用的对象。（反正只要通过new关键都是强引用）所以强引用可能会造成内存泄漏问题。（不回收）

软引用：是指用来描述一些还有用的对象但是不是必要的对象，它只关注软引用关联的对象，在系统要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收。（内存不足就回收）

弱引用：比软引用还要弱一点引用，它只被弱引用关联的对象只能生存到下一次垃圾收集发生为止，在系统GC时，只要发现弱引用，不管系统系统维护空间使用时是否充足，都会回收掉只被弱引用关联的对象。（发现即回收）

虚引用：是所有引用中最弱的一个，弱到一个对象是否有虚引用的存在，完全不会决定对象的生命周期，随时都可以被垃圾回收器回收。（对象回收跟踪）