## 基本SQL查询

#### 排序

```mysql
# 指定字段查询，并且将name排序（默认a-z）,降序desc
select name,deptld from tb1_emp order by name;
select name,deptld from tb1_emp order by name desc;
```

## 索引

### 1、基本操作

如何查看mysql提供什么存储引擎

```
show engines;
show variables like '%storage_engine';
```

MyISAM和InnoDB区别

MyISAM不支持主外键以及事物，表锁，即使操作一条记录也会锁住整个表，不适合做高并发，表空间大，只缓存索引不缓存真实数据。

索引优化

性能下降SQL满执行时间长等待时间长：查询语句写得烂、索引失效（单值、复合）、关联查询太多join（设计缺陷）、服务器各种参数设置（缓冲、线程数）

常见通用的join查询

建库

```mysql
create database db3306;
```

建表语句

```mysql
create table tb1_dept(
id int(11) not null auto_increment,
deptName varchar(30) default null,
locAdd varchar(40) default null,
primary key(id)
) engine=INNoDB auto_INCREMENT=1 default charset=utf8;

create table tb1_emp(
id int(11) not null auto_increment,
name varchar(20) default null,
deptld int(11) default null,
primary key(id)
) engine=INNoDB auto_INCREMENT=1 default charset=utf8;
```

插入

```mysql
INSERT INTO tb1_dept(deptName,locAdd) values('RD',11);
INSERT INTO tb1_dept(deptName,locAdd) values('HR',12);
INSERT INTO tb1_dept(deptName,locAdd) values('MK',13);
INSERT INTO tb1_dept(deptName,locAdd) values('MIS',14);
INSERT INTO tb1_dept(deptName,locAdd) values('FD',15);

INSERT INTO tb1_emp(NAME,deptld) values('z3',1);
INSERT INTO tb1_emp(NAME,deptld) values('z4',1);
INSERT INTO tb1_emp(NAME,deptld) values('z5',1);

INSERT INTO tb1_emp(NAME,deptld) values('w5',2);
INSERT INTO tb1_emp(NAME,deptld) values('w6',2);

INSERT INTO tb1_emp(NAME,deptld) values('s7',3);
INSERT INTO tb1_emp(NAME,deptld) values('s8',4);
INSERT INTO tb1_emp(NAME,deptld) values('s9',51);
```

第一种：

```
# 内联
select * from tbl_emp a inner join tbl_dept b on a.deptld = b.id;
# 左联
select * from tbl_emp a left  join tbl_dept b on a.deptld = b.id;
# 右联
select * from tbl_emp a right  join tbl_dept b on a.deptld = b.id;
# 左独有
select * from tbl_emp a left  join tbl_dept b on a.deptld = b.id where b.id is null;
# 右独有
select * from tbl_emp a right  join tbl_dept b on a.deptld = b.id where a.deptld is null;
# 全有
select * from tbl_emp a full outer  join tbl_dept b on a.deptld = b.id;
# 合并,union具有去重功能
select * from tbl_emp a inner join tbl_dept b on a.deptld = b.id union select * from tbl_emp a left  join tbl_dept b on a.deptld = b.id;
# 左独有 右独有
select * from tbl_emp a inner join tbl_dept b on a.deptld = b.id where b.id is null  union select * from tbl_emp a left  join
tbl_dept b on a.deptld = b.id where a.deptld is null;
```

### 2、索引（*********）

（1）介绍

官方描述：索引(Index)是帮助Mysql高效获取数据的数据结构。本质：索引是一种数据结构。

为什么要建索引？索引目的就是提高查询效率，排好序的快速查找数据结构。

索引优势：提高数据检索效率，降低数据库的IO成本，以及降低数据排序的成本，降低CPU的消耗。

索引劣势：虽然索引提高了查询效率，但是同时会降低更新表的速度（比如：insert、update和delete）。更新表慢的原因就是mysql不仅需要保存数据，还要保存一下索引文件每次更新添加了索引列字段，都会调整更新后带来的键值变化的索引信息。

（2）索引分类

* 单值索引：一个索引只包含单个列，一个表可以有多个单列索引

* 唯一索引：索引列值必须唯一，但不允许有空值

* 复合索引：即一个索引包含多个列

  ```
  # 创建
  create [unique] index indexName ON mytable(columnname(length));
  # 删除
  alter mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length);
  # 查看
  show index from table_name；
  # 使用alter命令
  # 该语句是添加一个主键，这意味着索引值必须是我唯一，且不能为null
  alter table tb1_name add primary key(column_list);
  
  # 这表语句创建一个索引值必须唯一的（除了null外，null可能回出现多次）
  alter table tb1_name add unique key(column_list);
  
  # 调价普通索引，索引值可出现多次
  alter table tb1_name add index key(column_list);
  
  # 该语句指定了索引为fullTEXT，用于全文索引
  alter table tb1_name add fulltext key(column_list);
  ```

* 基本索引

（3）索引结构

> Hash索引、Full-Text全文索引、R-Tree索引、BTree索引

BTree索引-检索原理：

（4）哪些情况需要创建索引

* 主键自动建立唯一索引
* 频繁作为查询条件字段应该创建索引（比如：银行系统银行账号）
* 查询中与其他表关联的字段，外键关系建立索引
* 频繁更新的字段不适合创建索引
* where条件里用不到的字段不创建索引
* 单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）
* 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
* 查询中统计或分组字段

（5）哪些情况下需要创索引

* 表记录太少（200百万）
* 经常增删改的表
* 数据重复且平均的表字段，因此应该 只为最经常查询和最经常排序的数据列建立索引。（如果数据包含许多重复内容，为它建立索引就没有太大的实际意义）

（6）性能分析

Mysql Query Optimizer自带查询优化器

Explain：使用explain关键字可以模拟优化器执行SQL查询语句，从而指导mysql是如何处理你的SQL语句。分析你的查询语句或是表结构的性能瓶颈。

explain能为你做什么？表的读取顺序，数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询。

explain使用语法：Explain + sql语句，记住以下表头面试能和聊

```mysql
mysql> explain select * from tb1_emp;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | tb1_emp | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    8 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
```

（*********）ID：

ID如果相同，可以认为是一组，从上往下顺序执行；在所有组中，ID值越大优先级越高，越先执行。（读取表顺序）

select_type有6中类型：

* simple：简单查询select查询，查询中不包含子查询或union
* primary：查询中若包含任何复查的子部分，最外层查询则被标记为
* subquery：在select或者where列表中包含子查询
* derived：在from列表中包含的子查询被逼阿吉为derived，mysql会递归执行这些子查询，把结构放在临时表里。
* union：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为：derived
* union result：从union表获取结果的select

Table：显示这一行的数据关于那张表

（*************）type：

访问类型排序，它显示查询使用何种类型：system>const>eq_ref>ref>range>index>ALL（顺序从最好到最差）

* const：表示通过索引一次就找到了，const用于比较primary key或union索引，因为只匹配一行数据所以很快，如将主键置于where列表中，mysql就能将该查询转换为一个常量。
* Eq_ref：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配，常见于主键或唯一索引扫描
* Ref：非唯一性索引扫描，返回匹配某个单独值的所有，本质也是一种索引访问，它返回所有匹配某个单独值的行，然后它可能会找多个符合的条件的行，索引它应该属于查询和扫描的混合体。
* range：只检索给定范围的行，使用一个索引来选择行，key列显示使用那个索引
* Index：full index scan，index与all区别为index类型只遍历索引树，这通常比all快，因为索引文件通常比数据文件小。（虽然all和index都是扫描全表，但是index是从索引中读取，而all从磁盘中读取）
* all：full table scan，将遍历全表以找到匹配的行

（*************）possible_key & key：

possible_key：显示可能引用在这张表中的索引，一个或多个，查询涉及到的字段存在索引，则该索引将被列出，但不一定被查询实际使用。

（7）热身 case

（8）索引优化

