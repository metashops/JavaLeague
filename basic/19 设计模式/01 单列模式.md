### 单例模式

> 应用场景：只需要一个实例的时候使用

1、第一种写法

饿汉式：

* 类加载到内存后，就实例一个单例，JVM保证线程安全
* 优点：简单实用
* 缺点：不管你用还是不用，只要类装载时就完成实例化了

```java
public class Singleton {
    // 使用final必须初始化
    private static final Singleton INSTANCE = new Singleton();
    /**
     * 把构造方法设置成私有的，这样new不了
     * 想要使用，怎么做呢？我们提供一个public方法getInstance进行调用
     */
    private Singleton() {}
    public static Singleton getInstance() {
        //不管你调用多少次getInstance，我永远只有一个INSTANCE = new Mgr01(
        return INSTANCE;
    }

    //证明是同一个实例
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();
        System.out.println(instance1 == instance);//如果返回true说明同一个实现
    }
}
```

2、第二种写法

懒汉式(lazy loading)：

* 何时用何时加载
* 缺点：当多线程访问下，假设A线程调用getInstance时，判断实例为空，则进行初始化，但是初始化之前，B线程也过来，判断该实例也为空，则进行初始化。最终两个线程new出来的已经不是同一个实例了。

```java
public class SingletonLazy {
    private static volatile SingletonLazy INSTANCE;
    private SingletonLazy(){}
    public static SingletonLazy getInstance() {
        //首先判断为空就初始化，第二次调用不为空就不初始化了
        if (null == INSTANCE) {
            //try/catch是为了测试使用的不用管
            try {
                Thread.sleep(10);
            } catch (Exception e) {
                e.printStackTrace();
            }
            INSTANCE = new SingletonLazy();
        }
        return INSTANCE;
    }
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                //hashCode不同，那么就不是同一个实例
                System.out.println(SingletonLazy.getInstance().hashCode());
            }).start();
        }
        //常规写法(上面是简写)
//        for (int i = 0; i < 100; i++) {
//            new Thread(new Runnable() {
//                @Override
//                public void run() {
//                    //...
//                }
//            }).start();
//        }
    }
}

```

3、第三种写法（也是懒汉式）

从上面我们知道，懒汉式出现的问题，我们使用synchronized关键字来解决，但是效率明显下降，因为每次都要看有没有锁。

```java
public class SingletonLazy {
    private static volatile SingletonLazy INSTANCE;
    private SingletonLazy(){}
    // synchronized锁住的是SingletonLazy.class
    public static synchronized SingletonLazy getInstance() {
        //首先判断为空就初始化，第二次调用不为空就不初始化了
        if (null == INSTANCE) {
            INSTANCE = new SingletonLazy();
        }
        return INSTANCE;
    }

```

4、第四种写法

双重检查或者双重判断

思路：先判断，再加锁，又在判断

> 很多人认为这种是最完美的

```java
public class SingletonDouble {
    private static volatile SingletonDouble INSTANCE = null;
    private SingletonDouble(){}
    public static SingletonDouble getInstance() {
        // 第一次判断为空，则上锁；如果不为空，那么就直接return INSTANCE
        if (null == INSTANCE) {
            synchronized (SingletonDouble.class) {
                // 第二次判断为空，则初始化
                if (null == INSTANCE) {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new SingletonDouble();
                }
            }
        }
        return INSTANCE;
    }

    //测试的不用管
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                System.out.println(SingletonDouble.getInstance().hashCode());
            }).start();
        }
    }
}
```

5、第五种写法

静态内部类写法：

加载外部类时不会加载内部类，这样可以实现懒加载(内部类在调用的使用才会加载)

```java
/**
 * 静态内部类
 */
public class Singleton2 {
    private Singleton2(){}
    private static class Singleton2Holder {
        private final static Singleton2 INSTANCE = new Singleton2();
    }
    public static Singleton2 getInstance() {
        return Singleton2Holder.INSTANCE;
    }
}
```

6、第六种写法

枚举方式：不仅可以解决线程同步，还可以防止序列化

```java
package com.hax.singleton;

public enum Singleton3 {
    INSTANCE;
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                Singleton3 instance = Singleton3.INSTANCE;
                System.out.println(instance.hashCode());
            }).start();
        }
    }
}

```

