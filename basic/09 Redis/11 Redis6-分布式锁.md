### Redis分布式锁

> 分布式锁如何实现的？

实现分布式锁，必须要求 Redis 有「互斥」的能力，Redis提供给我一个 SETNX 命令，这个命令表示（set if not exists），在操作时先判断 key 是否存在，不存在才会设置它的值，否则什么也不做。

假如A、B客户端进程去执行这个命令，要达到互斥，就可以实现一个分布式锁，谁先到谁先抢到，后面必须等我前面的释放锁。

```
127.0.0.1:6379> setnx lock 1
(integer) 1
127.0.0.1:6379> setnx lock 2
(integer) 0
127.0.0.1:6379>
```

用完后，就释放锁，让后面的使用，释放调用del指令

```
127.0.0.1:6379> del lock
(integer) 1
```

使用del有一个问题，可能会出现死锁，锁永远得不到释放。因为在逻辑执行到中间可能出现异常了，那么会导致 del 指令没有被调用。

一般我们设置锁时，给锁加上一个过期时间，等过期自动释放锁。

```
127.0.0.1:6379> expire lock 60 # 设置60秒过期后自动释放
(integer) 1
127.0.0.1:6379> ttl lock
(integer) 53
127.0.0.1:6379>
```

但是还是有问题，假如在 setnx 和 expire 之间服务器进程挂了，也会导致 expire 无法执行，也会造成死锁。

这时候解决，使用 setnx 和 expire 组合一起的原子指令。

```
127.0.0.1:6379> set lock 101 nx ex 60
OK
127.0.0.1:6379> set lock 101 nx ex 60
(nil)
127.0.0.1:6379> ttl lock
(integer) 51
127.0.0.1:6379>
```

这样就可以上锁的同时设置过期时间。