### 功能开发前期准备工作

1、我们先做页面跳转。登录功能，在controller层新建一个`LoginController`类。

```java
/**
 * 登录
 * @Slf4j 用来输出日志的，你可以不使用
 */
@RestController
@RequestMapping("/login")
@Slf4j
public class LoginController {
    /**
     * 功能描述：跳转登录页面
     * @return
     */
    @RequestMapping("toLogin")
    public String toLogin() {
        return "login";
    }
}
```

2、在resource目录下，写一个login登录页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
    <!--jquery-->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}" />
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- jquery-validator-->
    <script type="text/javascript" th:src="@{/jquery-validation/jquery.validate.min.js}"></script>
    <script type="text/javascript" th:src="@{/jquery-validation/localization/messages_zh.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.min.js}"></script>
    <!-- MD5.js -->
    <script type="text/javascript" th:src="@{/js/md5.min.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<form name="loginForm" id="loginForm" method="post" style="width: 50%; margin: 0 auto">
    <h2 style="text-align: center;margin-bottom: 20px">登录</h2>
    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入手机号码</label>
            <div class="col-lg-5">
                <input id="mobile" name="mobile" class="form-control" type="text" placeholder="手机号码" required="true" minlength="11" maxlength="11"/>
            </div>
            <div class="col-md-1"></div>
        </div>
    </div>
    <!-- 密码 -->
    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入密码</label>
            <div class="col-lg-5">
                <input id="password" name="password" class="form-control" type="password" placeholder="密码" required="true" minlength="8" maxlength="16"/>
            </div>
            <div class="col-md-1"></div>
        </div>
    </div>

    <!-- 重置 -->
    <div class="row">
        <div class="col-lg-5">
            <button class="bnt btn-primary btn-block" type="reset" onclick="reset()">重置</button>
        </div>
        <div class="col-lg-5">
            <button class="bnt btn-primary btn-block" type="submit" onclick="login()">登录</button>
        </div>
    </div>
</form>
</body>
<script>
    function login() {
        $("#loginForm").validate({
            submitHandler: function (form) {
                doLogin();
            }
        });
    }
    function doLogin() {
        g_showLoading();
        var inputPass = $("#password").val();
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + salt.charAt(3) + inputPass + salt.charAt(5) + salt.charAt(6);
        var password = md5(str);

        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function(data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg("成功");
                } else {
                    layer.msg(data.message);
                }
            },
            error: function() {
                layer.closeAll();
            }
        });
    }
</script>
</html>
```

3、实现doLogin方法

（1）在contrller层实现，也是在`LoginController`中实现。

```java
```

（2）在新建一个包和contrller平级vo，vo包主要编写我们的公共返回信息的，新建两个类`RespBean 和 RespBeanEunum`。

**RespBean 类**

```java
/**
 * 公共返回对象
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RespBean {
    private long code; // 状态码
    private String message; //对应消息
    private Object obj; // 有时候返回需要带一个对象
    
    // 成功返回结果
    public static RespBean success() {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBean.success().getMessage(),null);
    }
    public static RespBean success(Object obj) {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBean.success().getMessage(),obj);
    }
    
    // 错误返回结果,方法可以直接传入RespBeanEnum类
    public static RespBean error(RespBeanEnum respBeanEnum) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), null);
    }
    public static RespBean error(RespBeanEnum respBeanEnum,Object obj) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), obj);
    }

}

```



**RespBeanEnum 类**，是个枚举类，主要写一些状态

```java
/**
 * 公共返回对象枚举
 */
@Getter
@ToString
@AllArgsConstructor
public enum RespBeanEnum {
    SUCCESS(200,"SUCCESS"),
    ERROR(500,"服务端异常");
    //状态码
    private final Integer code;
    //相应信息
    private final String message;
}
```



### 开发登录功能

登录功能：点击“登录” —》 调用“login()”方法(执行doLogin()之前还做一层较验) ,doLogin方法如下：

```
function doLogin() {
        g_showLoading();
        var inputPass = $("#password").val();
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
        var password = md5(str);
        //通过ajax调用后端接口
        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function(data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg("成功");
                } else {
                    layer.msg(data.message);
                }
            },
            error: function() {
                layer.closeAll();
            }
        });
```

前端调试快捷键：`command+option+i`，前端400

该提示只能在控制台提示，为什么不在页面显示？

```html
{"timestamp":"2021-10-01T16:19:04.189+00:00","status":400,"error":"Bad Request","path":"/login/doLogin"}
```

此时，我们应该将该错误收集，然后返回页面。也就是“异常处理”

SpringBoot的全局异常处理有两种：第一种使用ConstraintValidator，只能处理控制器的异常；可以处理所有异常包括没有进入控制器



## Redis 实现分布式Session

第一种：使用springsession去实现分布式Session，把项目中的session统一存在redis中，所有的参与集群的项目都在redis中取，这样就不不会出现明明在session中设了值但取不到值的情况。

依赖

```xml
        <!-- spring data redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```

yml配置

```yml
  redis:
    # 服务器地址
    host:  192.168.1.3
    # 端口
    port: 6379
    # 数据库
    database: 0
    # 超时时间
    timeout: 10000ms
    lettuce:
      pool:
        # 最大连接数，默认8 
        max-active: 8
        # 最大阻塞等待时间默认-1
        max-wait: 1000ms
        # 最大空闲连接，默认8
        max-idle: 200
        # 最小空闲连接默认0
        min-idle: 5
```

这样就可以使用Redis实现分布式Session，结果是二进制的

第二种：通过Redis去实现（从session提取信息存入Redis）

使用token代替session，这样就不会引起分布式session问题。这里我们需要提一个问题，项目中使用到了session，那么即使使用springsession解决分布式session一致性的问题，只要你换了一个浏览器操作，那么同样因为sessionID丢失的问题，也同样获取不到值，为了彻底解决分布式session的问题，那么我们可以用token代替session

```java
/**
 * Redis 配置类
 */
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // key系列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // value系列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        //hash类型，key序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        // hash 类型 value序列化
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        // 注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;

    }
```



修改userServiceImpl类

```java
   			 // 先注入
   			 @Autowired
   			 private RedisTemplate redisTemplate;       
				// 生成cookie
        String ticket = UUIDUtil.uuid();
        // 不用了
        // request.getSession().setAttribute(ticket,user);
        // 修改为
        redisTemplate.opsForValue().set("user"+ticket,user);
        CookieUtil.setCookie(request,response,"userTicket",ticket);
        return RespBean.success();
    @Override
    public User getUserByCookie(String userTicket,HttpServletRequest request,HttpServletResponse response) {
        if (StringUtils.isEmpty(userTicket)) {
            return null;
        }
        User user = (User) redisTemplate.opsForValue().get("user" + userTicket);
        if (user != null) {
            CookieUtil.setCookie(request,response,"userTicket",userTicket);
        }
        return user;
    }
}
```

redis存储的是一下内容：

```redis
{
  "@class": "com.xxxx.seckilldemo.pojo.User",
  "id": 18012345678,
  "nickname": "adimin",
  "slat": "1a2b3c4d",
  "head": null,
  "registerDate": null,
  "lastLoginDate": null,
  "loginCount": 0,
  "pssword": "f5aa712fcda2aaeb013b40cd90da4d4a"
}
```

## 再次优化登录功能

优化前：

```java
@RestController
@RequestMapping("/goods")
public class GoodsController {
    @Autowired
    private IUserService userService;
    @RequestMapping("/toList")
    public String toList(HttpServletRequest request, HttpServletResponse response, Model model, @CookieValue("userTicket") String ticket) {
        if (StringUtils.isEmpty(ticket)) {
            return "login";
        }
        // 使用Redis就不用这个了
        //User user = (User) session.getAttribute(ticket);
        User user = userService.getUserByCookie(ticket, request, response);
        if (null == user) {
            return "login";
        }
        model.addAttribute("user",user);
        return "goodsList";
    }
}
```

优化操作：

