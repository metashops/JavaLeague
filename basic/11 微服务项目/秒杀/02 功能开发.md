### 功能开发前期准备工作

1、我们先做页面跳转。登录功能，在controller层新建一个`LoginController`类。

```java
/**
 * 登录
 * @Slf4j 用来输出日志的，你可以不使用
 */
@RestController
@RequestMapping("/login")
@Slf4j
public class LoginController {
    /**
     * 功能描述：跳转登录页面
     * @return
     */
    @RequestMapping("toLogin")
    public String toLogin() {
        return "login";
    }
}
```

2、在resource目录下，写一个login登录页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
    <!--jquery-->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}" />
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- jquery-validator-->
    <script type="text/javascript" th:src="@{/jquery-validation/jquery.validate.min.js}"></script>
    <script type="text/javascript" th:src="@{/jquery-validation/localization/messages_zh.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.min.js}"></script>
    <!-- MD5.js -->
    <script type="text/javascript" th:src="@{/js/md5.min.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<form name="loginForm" id="loginForm" method="post" style="width: 50%; margin: 0 auto">
    <h2 style="text-align: center;margin-bottom: 20px">登录</h2>
    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入手机号码</label>
            <div class="col-lg-5">
                <input id="mobile" name="mobile" class="form-control" type="text" placeholder="手机号码" required="true" minlength="11" maxlength="11"/>
            </div>
            <div class="col-md-1"></div>
        </div>
    </div>
    <!-- 密码 -->
    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入密码</label>
            <div class="col-lg-5">
                <input id="password" name="password" class="form-control" type="password" placeholder="密码" required="true" minlength="8" maxlength="16"/>
            </div>
            <div class="col-md-1"></div>
        </div>
    </div>

    <!-- 重置 -->
    <div class="row">
        <div class="col-lg-5">
            <button class="bnt btn-primary btn-block" type="reset" onclick="reset()">重置</button>
        </div>
        <div class="col-lg-5">
            <button class="bnt btn-primary btn-block" type="submit" onclick="login()">登录</button>
        </div>
    </div>
</form>
</body>
<script>
    function login() {
        $("#loginForm").validate({
            submitHandler: function (form) {
                doLogin();
            }
        });
    }
    function doLogin() {
        g_showLoading();
        var inputPass = $("#password").val();
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + salt.charAt(3) + inputPass + salt.charAt(5) + salt.charAt(6);
        var password = md5(str);

        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function(data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg("成功");
                } else {
                    layer.msg(data.message);
                }
            },
            error: function() {
                layer.closeAll();
            }
        });
    }
</script>
</html>
```

3、实现doLogin方法

（1）在contrller层实现，也是在`LoginController`中实现。

```java
```

（2）在新建一个包和contrller平级vo，vo包主要编写我们的公共返回信息的，新建两个类`RespBean 和 RespBeanEunum`。

**RespBean 类**

```java
/**
 * 公共返回对象
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RespBean {
    private long code; // 状态码
    private String message; //对应消息
    private Object obj; // 有时候返回需要带一个对象
    
    // 成功返回结果
    public static RespBean success() {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBean.success().getMessage(),null);
    }
    public static RespBean success(Object obj) {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBean.success().getMessage(),obj);
    }
    
    // 错误返回结果,方法可以直接传入RespBeanEnum类
    public static RespBean error(RespBeanEnum respBeanEnum) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), null);
    }
    public static RespBean error(RespBeanEnum respBeanEnum,Object obj) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), obj);
    }

}

```



**RespBeanEnum 类**，是个枚举类，主要写一些状态

```java
/**
 * 公共返回对象枚举
 */
@Getter
@ToString
@AllArgsConstructor
public enum RespBeanEnum {
    SUCCESS(200,"SUCCESS"),
    ERROR(500,"服务端异常");
    //状态码
    private final Integer code;
    //相应信息
    private final String message;
}
```



### 开发登录功能

登录功能：点击“登录” —》 调用“login()”方法(执行doLogin()之前还做一层较验) ,doLogin方法如下：

```
function doLogin() {
        g_showLoading();
        var inputPass = $("#password").val();
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
        var password = md5(str);
        //通过ajax调用后端接口
        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function(data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg("成功");
                } else {
                    layer.msg(data.message);
                }
            },
            error: function() {
                layer.closeAll();
            }
        });
```

前端调试快捷键：`command+option+i`，前端400

该提示只能在控制台提示，为什么不在页面显示？

```html
{"timestamp":"2021-10-01T16:19:04.189+00:00","status":400,"error":"Bad Request","path":"/login/doLogin"}
```

此时，我们应该将该错误收集，然后返回页面。也就是“异常处理”

SpringBoot的全局异常处理有两种：第一种使用ConstraintValidator，只能处理控制器的异常；可以处理所有异常包括没有进入控制器



## Redis 实现分布式Session

第一种：使用springsession去实现分布式Session，把项目中的session统一存在redis中，所有的参与集群的项目都在redis中取，这样就不不会出现明明在session中设了值但取不到值的情况。

依赖

```xml
        <!-- spring data redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```

yml配置

```yml
  redis:
    # 服务器地址
    host:  192.168.1.3
    # 端口
    port: 6379
    # 数据库
    database: 0
    # 超时时间
    timeout: 10000ms
    lettuce:
      pool:
        # 最大连接数，默认8 
        max-active: 8
        # 最大阻塞等待时间默认-1
        max-wait: 1000ms
        # 最大空闲连接，默认8
        max-idle: 200
        # 最小空闲连接默认0
        min-idle: 5
```

这样就可以使用Redis实现分布式Session，结果是二进制的

第二种：通过Redis去实现（从session提取信息存入Redis）

使用token代替session，这样就不会引起分布式session问题。这里我们需要提一个问题，项目中使用到了session，那么即使使用springsession解决分布式session一致性的问题，只要你换了一个浏览器操作，那么同样因为sessionID丢失的问题，也同样获取不到值，为了彻底解决分布式session的问题，那么我们可以用token代替session

```java
/**
 * Redis 配置类
 */
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // key系列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // value系列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        //hash类型，key序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        // hash 类型 value序列化
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        // 注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;

    }
```



修改userServiceImpl类

```java
   			 // 先注入
   			 @Autowired
   			 private RedisTemplate redisTemplate;       
				// 生成cookie
        String ticket = UUIDUtil.uuid();
        // 不用了
        // request.getSession().setAttribute(ticket,user);
        // 修改为
        redisTemplate.opsForValue().set("user"+ticket,user);
        CookieUtil.setCookie(request,response,"userTicket",ticket);
        return RespBean.success();
    @Override
    public User getUserByCookie(String userTicket,HttpServletRequest request,HttpServletResponse response) {
        if (StringUtils.isEmpty(userTicket)) {
            return null;
        }
        User user = (User) redisTemplate.opsForValue().get("user" + userTicket);
        if (user != null) {
            CookieUtil.setCookie(request,response,"userTicket",userTicket);
        }
        return user;
    }
}
```

redis存储的是一下内容：

```redis
{
  "@class": "com.xxxx.seckilldemo.pojo.User",
  "id": 18012345678,
  "nickname": "adimin",
  "slat": "1a2b3c4d",
  "head": null,
  "registerDate": null,
  "lastLoginDate": null,
  "loginCount": 0,
  "pssword": "f5aa712fcda2aaeb013b40cd90da4d4a"
}
```

## 再次优化登录功能

优化前：

```java
@RestController
@RequestMapping("/goods")
public class GoodsController {
    @Autowired
    private IUserService userService;
    @RequestMapping("/toList")
    public String toList(HttpServletRequest request, HttpServletResponse response, Model model, @CookieValue("userTicket") String ticket) {
        if (StringUtils.isEmpty(ticket)) {
            return "login";
        }
        // 使用Redis就不用这个了
        //User user = (User) session.getAttribute(ticket);
        User user = userService.getUserByCookie(ticket, request, response);
        if (null == user) {
            return "login";
        }
        model.addAttribute("user",user);
        return "goodsList";
    }
}
```

优化操作：

## 登录功能总结：

两次MD5加密

* 第一次加密，防止明文密码在网络传播
* 第二次加密，以防万一，数据库被别人获取到

使用validation组件来做手机号码验证规则

Redis实现分布式session

就是因为秒杀嘛，肯定会有大量并发，这时候我们需要多台服务器的，如果使用cookie+session的会有问题，在做反向代理的时候有可能在服务器A产生session，然后秒杀完后到其他页面的时候，有可能去B服务，但是这时候用户sessionID是在A服务的，这样又让用户登录，显然不合理。

解决session问题方案也有很多的：比如session复制，前端存储



## 功能实现

#### 1、商品列表页

首先分析我们商品列表需要返回哪些东西：商品名称、商品图片、商品价格、商品原价、详情页

秒杀表，我们需要通过ID关联商品表

第一步：写我们返回哪些数据字段，统一在VO目录写

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GoodsVo extends Goods {
    private BigDecimal seckillPrice;
    private String stockCount;
    private Date startDate;
    private Date endDate;
}
```

第二步：写service层接口和实现类

接口

```java
public interface ISeckillGoodsService extends IService<SeckillGoods> {
    // 我们返回list，Goods对象
    List<Goods> findGoodsVo();
}
```

实现类

```java
@Service
public class SeckillGoodsServiceImpl extends ServiceImpl<SeckillGoodsMapper, SeckillGoods> implements ISeckillGoodsService {
    // 获取数据，我们去数据库查询
    @Autowired
    private GoodsMapper goodsMapper;
    @Override
    public List<Goods> findGoodsVo() {
        return goodsMapper.findGoodsVo();//去调用持久层方法
    }
}
```

第三步：如果持久层没有写findGoodsVo，那就先去写

```java
public interface GoodsMapper extends BaseMapper<Goods> {
    List<Goods> findGoodsVo();//获取商品列表
}
```

第四步：去 `src/main/resources/mapper/GoodsMapper.xml `写我们的SQL语句



## 秒杀功能总结

建立四个表：商品表、秒杀商品表、订单表、秒杀订单表

秒杀：首先判断，先去秒杀商品表里面去减库存，生成订单，然后再生成秒杀订单

通过Jmeter压测工具，也出现库存超买问题，库存数量变成-1了，超买问题，刚开始QPS提升不是很大的，后面的话提升很快，因为库存卖完了

## 页面优化总结

页面缓存、对象缓存、秒杀静态缓存，这样减少对数据库的查询，

重点解决超买问题，我给了数据库加唯一索引，防止用户重复购买，对SQL优化，简单的判断库存的数量的判断，防止库存的变成负数

在高并发下，使用RabbitMQ解决下单问题，因为在下单的时候，大量并发请求过来直接去请求数据库，数据库是扛不住的，然后使用RabbitMQ实现，先让请求进入队列进行缓冲，通过队列异步下单，这样可以增强用户体验。
