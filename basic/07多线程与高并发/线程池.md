

## 线程池

>  概念

线程池（thread pool）：是一种线程使用模式。线程过多会带来调度开销，进而影响缓存和整体性能。而线程池维护着多个线程，等待着监督管理者分配课并发执行任务。者避免了处理段时间任务创建与销毁线程的代价。线程池不仅能保证内核的充分利用还能防止过分调度。



> 为什么要用线程池？

（1）创建/销毁线程需要消耗系统资源，而线程池可以做到复用已创建的线程，从而降低系统资源的消耗。

（2）控制并发的数量。如果并发数量过多，可能会导致资源消耗过多，从而造成服务器崩贵。

（3）可以对线程的统一管理



> 4种常见的线程池及使用方式

* 一池N线程：Executors.newFixedThreadPool(int)

* 一个任务一个任务执行，一池一线：Executors.newSingleThreadExecutor()

* 线程池根据需求创建线程，可扩容，遇强则强：Executors.newCachedThreadPool()
* 创建一个定长线程池，支持定时和周期性任务执行：Executors.newScheduledThreadPool

创建：

```java
public class ThreadPoolDemo1 {
    public static void main(String[] args) {
        // 一池5个线程
        ExecutorService threadPool1 = Executors.newFixedThreadPool(5);
        // 一池一个线程
        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();
        //一池多个线程
        ExecutorService threadPool3 = Executors.newCachedThreadPool();
      
        ScheduledExecutorService threadPool4 = Executors.newScheduledThreadPool(2);
        // 10个顾客请求
        try {
            for (int i = 1; i < 11; i++) {
                //执行
                threadPool3.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPool3.shutdown();
        }
    }
}
```

**虽然四种常见线程池够使用了，但是一般我们没有去使用，而是使用《阿里巴巴开发手册》建议通过ThreadPoolExecutor的方式去使用，这样能够让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。**



> 为什么不建议使用Executors去类中线程池？

Executors创建的弊端：

* FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
* CachedThreadPool 和 ScheduleThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。





> 线程池原理

Java中的线程池最顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。

![Snip20210902_7.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gu2e36tmk3j30uc0m0tar.jpg)

ThreadPoolExecutor 提供了4个构成方法，大家可以点开源码看看就好了，以下说明构成方法中的参数代表意思：

```java
// 7个参数
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 
```

* int corePoolSize：核心线程数的最大值

* int maximumPoolSize：用于设置该线程池中线程总数最大值

* long keepAliveTime：表示非核心线程的存活时间（也就是说非核心线程处于闲置超过设定的值就会被销毁）

* TimeUnit unit：
* BlockingQueue<Runnable> workQueue：阻塞队列（维护等待线程的Runnable任务对象）
  * LinkedBlockingQueue（链式阻塞队列）
  * ArrayBlockingQueue（数组阻塞队列）
  * SynchronousQueue（同步队列）
  * DelayQueue（延迟队列）
* ThreadFactory threadFactory：线程工厂，主要用于批量创建线程（非必须）
* RejectedExecutionHandler handler：拒绝策略，用于设置当线程数量大于线程数就会采用拒绝处理策略。
  * ThreadPoolExecutor.AbortPolicy
  * ThreadPoolExecutor.DiscardPolicy
  * ThreadPoolExecutor.DiscardOldestPolicy
  * ThreadPoolExecutor.CallerRunsPolicy



> 通过ThreadPoolExecutor自定义线程池

自定义线程池：

```java
public class ThreadPoolDemo2 {
    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,
                5,
                2L,
                TimeUnit.MICROSECONDS,
                new ArrayBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        //处理10个顾客
        try {
            for (int i = 1; i <= 10; i++) {
                threadPoolExecutor.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPoolExecutor.shutdown();
        }
    }
}

```

> 线程池的execute核心方法

处理任务的核心方法是execute，以下是Java 11源码

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        // 判断当前线程数如果小于corePoolSize（核心线程最大值），则会调用addWorker创建核心线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 如果当前线程数大于corePoolSize，则会将任务添加到workQueue队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 如果放入workQueue（阻塞队列）失败，则创建非核心线程执行任务
        //如果创建非核心线程失败，那么就会执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
```

总结：

1、线程总数量 < 核心线程最大值(CorePoolSize)，无论线程是否空闲都会创建一个核心线程执行任务

2、线程总数量 >= 核心线程最大值(CorePoolSize)，新来的线程任务会进入阻塞队列等待，然后空闲的核心线程会依次去缓存队列中取出任务来执行。（需要索取全局锁）

3、如果缓存队列满了，说明这时候任务已经装不下了，那么需要临时工来执行这些任务，于是又会创建非核心线程去执行这个任务（需要索取全局锁）。如果缓存队列满了并且线程数量达到了MaxmumPoolSize时，则采取拒绝策略方式进行处理。



>ThreadPoolExecutor 如何做到线程复用？

addWorker源码：

```java
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (int c = ctl.get();;) {
            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    || firstTask != null
                    || workQueue.isEmpty()))
                return false;

            for (;;) {
                if (workerCountOf(c)
                    //如果core是ture，证明需要创建线程为核心线程，则先判断当前线程是否大
                    //如果core是false，证明需要创建非核心线程，则先判断当前线程数是否大
                    //如果不小于，则返回false
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateAtLeast(c, SHUTDOWN))
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
      boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 1.创建一个worker对象
            w = new Worker(firstTask);
           // 2.实例化一个Thread对象
            final Thread t = w.thread;
            if (t != null) {
                // 3.线程池全局锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();

                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        workerAdded = true;
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    // 4.启动该线程
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

总结：

1、首先做一个判断线程数量是否超出阈值，超出返回false

2、第二步才去创建worker对象

3、然后初始化Thread对象

4、最后启动该线程对象



> Worker 源码分析

```java
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    try {
                        //任务执行
                        task.run();
                        afterExecute(task, null);
                    } catch (Throwable ex) {
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

总结：

当执行完任务后，worker生命周期并没有结束，在while循环中，worker会不断调用getTask()方法从阻塞队列中获取renew然后调用task.run()执行任务（这就是达到复用线程的目的）



> getTask方法源码

```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();

            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            // allowCoreThreadTimeOut默认false，核心线程即使空也不会被销毁
            // 为true则核心线程在keepAliveTime内空闲就会被销毁
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            // 如果运行线程数量超过最大线程数，但缓存队列已经空，这时候递减worker数量
            // 如果有设置允许线程超过或者线程数量超过了核心线程数量，并且线程在规定时间内为Poll到任务且
            // 队列为空则递减worker数量
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

```

