## 基本简介

> 1、JUD 是什么？

JUC 就是 java.util.concurrent 工具包的简称，这是是处理线程的工具包，JDK1.5 开始出现的。



> 2、进程 与 线程区别？

process是计算机中的程序关于某数据集合上的一次活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其他组织形式的描述，进程是程序的一个实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源和调度的基本单位，是操作系统结构的基础。程序是指令、数据集其他组织形式的描述，进程是程序的实体。

（1）进程：是指系统中正在运行的一个应用的程序，是系统进行资源分配和调度的基本单位。

（2）线程：是系统分配处理时间资源的基本单元，是进程里面的一个独立执行单位。

> 3、线程的状态？





> 4、wait 与 sleep 区别？

（1）sleep 是Thread的静态方法，wait 是Object的方法，任何对象实例都可以能调用。

（2）sleep 不会释放锁，它也不需要占用锁；wait 会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）

（3）相同的是都可以被interrupt方法中断



> 5、并发 与 并行？

并发：是指同一时刻多个线程在放访问同一个资源（电商秒杀、春运抢票）

并行：多项工作一起执行



> 6、管程（monitor/监视器）

是一种同步机制，保证同一个时间，只有一个线程访问被保护数据或者代码。（如进入某个线程时需要加锁，退出就要解锁，是通过monitor或者管程对象实现的）



> 7、用户线程和守护线程

用户线程：自定义的线程

守护线程：比如垃圾回收



> 8、Synchronized 关键字

> 多线程编程步骤：
>
> （1）创建资源类，在资源类创建属性和操作方法
>
> （2）创建多个线程，调用资源类的操作方法

synchronized 是 Java 中的一个关键字，是一种同步锁，它修饰的对象有以下几种：

1. 修饰一个代码块，被修饰的代码块称为同步语句块。其作用范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。
2. 修饰一个方法。被修饰的方法称为同步方法，起作用的范围是整个方法，作用的对象是调用这个方法的对象。

> 9、Lock

Lock锁实现提高比使用同步方法和语句可以获得的更广泛的锁操作。

> 10、Lock 与 synchronized区别？

（1）Lock是一个接口，不是Java语言内置的，而synchronized是Java语言关键字，Lock是一个类，通过这个类可以实现同步访问。

（2）synchronized  不需要用户去手动释放锁，执行代码块结束系统会自动让线程释放对锁的占用。Lock则必须手动释放锁，如果不主动释放可能会导致死锁现象。

## synchronized 和 Lock实现售票案例

3个售票员 卖出30张票。分析：票是资源，30张是属性，3个售票员是三个方法或者三个线程，三个线程同时操作共享使用30张票。

synchronized 实现：

```java
class Ticket {
    //票数
    private int number = 30;
    //操作方法，卖票
    public synchronized void sale() {
        //判断票是否还有
        if (number > 0) {
            System.out.println(Thread.currentThread().getName()+"：卖出："+(number--)+"剩下："+number);
        }
    }
}

public class SynchronizedTest {
    public static void main(String[] args) {
        //创建Ticker
        Ticket ticket = new Ticket();
        //创建三个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                //调用卖票方法
                for (int i = 0;i < 40;i++) {
                    ticket.sale();
                }
            }
        },"线程AA").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                //调用卖票方法
                for (int i = 0;i < 40;i++) {
                    ticket.sale();
                }
            }
        },"线程BB").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                //调用卖票方法
                for (int i = 0;i < 40;i++) {
                    ticket.sale();
                }
            }
        },"线程CC").start();
    }
}

```

Lock 实现：

可重入锁

```java
//票类
class LTicket{
    //属性
    private int number = 30;
    //创建可重入锁
    private final ReentrantLock lock = new ReentrantLock();
    //方法
    public void sale() {
        //上锁
        lock.lock();
        try {
            //判断票是否还有
            if (number > 0) {
                System.out.println(Thread.currentThread().getName()+"：卖出："+(number--)+"剩下："+number);
            }
        } finally {//finally 作用就是不管有没有异常最终都会实行finally里面代码
            //释放锁
            lock.unlock();
        }
    }
}
public class LockTest {
    public static void main(String[] args) {
        LTicket lticket = new LTicket();
        //创建线程
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程AA").start();

        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程BB").start();

        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程CC").start();
    }
}

```

注：start可以马上创建也可以不一定马上创建不确定的



### 线程间通信案例

```java
package com.cathax;
// 第一步：创建资源定义属性和操作方法
class Share {
    //初始值
    private int number = 0;
    // +1 的方法
    public synchronized void incr() throws InterruptedException {
        //第二步：判断、干活、通知
        if (number != 0) { // 为1说明被占用则等待，是0就加1
            this.wait();
        }
        //如果number=0，则+1
        number++;
        System.out.println(Thread.currentThread().getName()+"::"+number);
        //通知
        this.notifyAll();
    }
    // -1 的方法
    public synchronized void decr() throws InterruptedException {
        //第二步：判断、干活、通知
        if (number != 1) {
            this.wait();
        }
        //干活
        number--;
        //通知其他线程
        this.notifyAll();
    }
}
public class ThreadDemo1 {
    //第三步：创建多个线程，调用资源类的操作方法
    public static void main(String[] args) {
        Share share = new Share();
        new Thread(() -> {
            for (int i= 0; i <= 40;i++) {
                try {
                    share.incr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程AA").start();

        new Thread(() -> {
            for (int i= 0; i <= 40;i++) {
                try {
                    share.decr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程BB").start();
    }
}

```

上述会出现虚假问题

```java
package com.cathax;
// 第一步：创建资源定义属性和操作方法
class Share {
    //初始值
    private int number = 0;
    // +1 的方法
    public synchronized void incr() throws InterruptedException {
        //第二步：判断、干活、通知
        while (number != 0) { // 为1说明被占用则等待，是0就加1
            this.wait();
        }
        //如果number=0，则+1
        number++;
        System.out.println(Thread.currentThread().getName()+"::"+number);
        //通知
        this.notifyAll();
    }
    // -1 的方法
    public synchronized void decr() throws InterruptedException {
        //第二步：判断、干活、通知
        while (number != 1) {//等待它为1，我们再执行-1，不等1就等待
            this.wait();
        }
        //干活
        number--;
        System.out.println(Thread.currentThread().getName()+"::"+number);
        //通知其他线程
        this.notifyAll();
    }
}
public class ThreadDemo1 {
    //第三步：创建多个线程，调用资源类的操作方法
    public static void main(String[] args) {
        Share share = new Share();
        new Thread(() -> {
            for (int i= 0; i <= 10;i++) {
                try {
                    //Thread.sleep(1000);
                    share.incr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程AA").start();

        new Thread(() -> {
            for (int i= 0; i <= 10;i++) {
                try {
                    share.decr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程BB").start();
        new Thread(() -> {
            for (int i= 0; i <= 10;i++) {
                try {
                    share.incr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程CC").start();
        new Thread(() -> {
            for (int i= 0; i <= 10;i++) {
                try {
                    share.decr();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程DD").start();
    }
}

```





3、死锁

死锁：是指两个或者多个进程在执行过程中，因为竞夺资源而造成一种相互等待的现象，如果没有外力的干涉下，就无法执行下去。

造成死锁原因：

* 系统资源不足
* 进程运行推测顺序不合适
* 资源分配不当



4、Callable 接口

目前两种创建线程方式：通过创建Thread类以及使用Runnable创建线程。（注：Runnable缺少的一项功能是，当线程终止时（run完成时），我们无法使用线程返回结果，为类支持此功能，Java提供啦callable接口）

Runnable 和 Collable 接口区别？

> 是否有返回值
>
> 是否抛出异常
>
> 实现方法名称不同，一个run方法一个call方法



5、JUC的辅助类

（1）减少计数CountDownLatch

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 第一步：创建countDownLatch对象，设置初始值
        CountDownLatch count = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"号同学离开教室");
                // 第二部：每次计数器 -1
                count.countDown();
            },String.valueOf(i)).start();
        }
        // 第三步：等待
        count.await();
        System.out.println(Thread.currentThread().getName()+"锁门");
    }
}
```

（2）循环栅栏 CyclicBarrier

```java
public class CyclicBarrierDemo {
    //创建固定值
    private static final int NUMBER = 7;
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER,() -> {
            System.out.println("非常棒，终于齐集7课龙珠");
        });
        for (int i = 1; i <= 7; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"星龙被收集了");
                //await
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}

```



（3）星号灯 Semaphore

是一个计数信号量，维护了一个许可集。案例实现：6辆汽车，停3个车位

```java
// 模拟：6辆汽车，停3个车位
public class SemaphoreDemo {
    public static void main(String[] args) {
        //创建semaphore，设置许可量
        Semaphore semaphore = new Semaphore(3);
        //模拟6辆汽车
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                //抢车位
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"终于抢到车位");
                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //释放车位
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}

```



## synchronized

synchronized的三种使用情况：

（1）对于普通同步方法，锁是当前实例对象

```java
public SyncDemo{
   Object lock =new Object();
    // 方式1
    public synchronized void access(){
       //
    }
    // 方式2,作用域等= 方式1
    public void access1(){
       synchronized(lock){
         //
       }
    }
    //方式3，作用域等同于前面两种
    public void access2(){
       synchronized(this){
          //
       }
    }
}
```

（2）对于静态同步方法，锁是当前类的class对象

```java
public SyncDemo{
    static Object lock = new Object();
    // 写法 1
    public synchronized static void access(){
       //
    }
    // 写法2等 = 写法1
    public void access1(){
       synchronized(lock){
          //
       }
    }
}
```

（3）对于同步方法块，锁是synchronized括号配置的对象

```java
public SyncDemo{
   Object lock=new Object();
   public void access(){
       //do something
       synchronized(lock){
         //
       }
   }
}

```

synchronized 原理分析

> 如果一个线程去访问被synchronized所修饰的代码块时，它首先就是必须获取锁，大家想一想，到底去哪里获得这个锁？锁里面有什么神奇的东西？

synchronized 实现的锁是存储在Java对象头里。对象头是对象在内存中的存储布局。划分三个区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)。

当new创建一个对象实例的时候，在JVM层面会创建一个instanceOopDesc对象，用来描述对象头的。当你查看instanceOopDesc源码发现是继承自oopDesc的，而oopDesc定义包含两个成员，分别是 _mark和 _metadata（前者用于记录对象和锁状态有关信息，后者用于存储对象指向它的元数据地址）。

synchronized 的原理在JVM里使用**Monitor(监听器)**来实现对象方法同步和代码同步的。然后监听器里面由monitorenter 和 monitorexit 指令实现的。

synchronized在 JDK 1.6开始有哪些优化？

在多线程并发编程中synchronized一直是元老级的锁，它是重量级锁。但在JDK 1.6开始为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁 和 轻量级锁”，从低到高共有四种状态：无锁状态 -> 偏向锁状态 -> 轻量级锁状态 -> 重量级锁状态。值得注意的是，锁可以升级但不能降级，这样的目的就是为了提高获得锁和释放的效率。



## 锁升级

在多线程并发编程中synchronized一直是元老级的锁，它是重量级锁。但在JDK 1.6开始为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁 和 轻量级锁”，从低到高共有四种状态：无锁状态 -> 偏向锁状态 -> 轻量级锁状态 -> 重量级锁状态。值得注意的是，锁可以升级但不能降级，这样的目的就是为了提高获得锁和释放的效率。

（1）偏向锁：

在大多数的情况下，锁不仅不存在多线程的竞争，而且总是由同一个线程获得，因此为了让线程获得锁的代价更低引入了偏向锁的概念。

初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位）。当执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID在对象头里），是则正常往下执行。由于之前没有释放锁，则不需要重新加锁。如果使用锁的线程只有一个，那么可看出偏向锁几乎没有额外开销，性能极高。偏向锁可通过 -XX:+UseBiasedLocking开启或者关闭

**偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁**，不过偏向锁的撤销，需要等待全局安全点。

> 适用场景：适用只有一个线程访问同步代码块的场景。（目的就是不想让它带来撤销时额外的消耗）



（2）轻量级锁

> 什么时候升级为轻量级锁？

是指当锁已经偏向锁的时候，被其他线程访问，此时会发生偏向锁的撤销并升级为轻量级锁。偏向锁撤销会有两种状态升级为轻量级锁：第一种是已经获得偏向锁的线程已经退出，撤销偏向锁后会会升级为轻量级锁；第二种就是已经获得偏向锁的线程正在执行同步代码块，这时候会升级为轻量级锁。

> 适用场景：追求响应时间同步块执行速度非常快的场景

（3）重量级锁

重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。它是将所有的控制权交由操作系统来负责线程间的调度和线程的状态变更。相当于从用户态转化到内核态，而转化状态是需要消耗时间的。（简而言之：重量级锁相当从用户态转化内核态，则系统开销很大）

> 什么时候升级为重量级锁

如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁

>适用场景：追求吞吐量同步快执行速度较长



## 可重入锁 和 非重入锁

重入锁就是支持重新进入的锁，也就是说支持一个线程对资源重复加锁。

> synchronized（隐式）Lock（显示）都是可重入锁

特点：就是可以自由的一层一层访问，类似递归

synchronized（隐式）：

```java
public class SynLockDemo {
    public static void main(String[] args) {
        Object o = new Object();
        new Thread(() -> {
            synchronized (o) {
                System.out.println(Thread.currentThread().getName()+"外层");
                synchronized (o) {
                    System.out.println(Thread.currentThread().getName()+"中层");
                    synchronized (o) {
                        System.out.println(Thread.currentThread().getName()+"内层");
                    }
                }
            }
        },"t1").start();
    }
}
```

Lock（显示）：

```java
public class LockDemo1 {
    public static void main(String[] args) {
        //演示可重入锁
        Lock lock = new ReentrantLock(true);
        //创建线程
        new Thread(() -> {
            try {
                lock.lock();//上锁
                System.out.println(Thread.currentThread().getName()+"外层");
                try {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName()+"内层");
                } finally {
                    lock.unlock();
                }
            } finally {
                lock.unlock();//解锁
            }
        },"t1").start();
    }
}

```



## 公平锁和非公平锁

非公平锁：线程可能会出现线程饿死，但效率高（默认使用非公平）

公平锁：不会出现饿死，但效率低

实现：

```java
//票类
class LTicket{
    //属性
    private int number = 30;
    //创建可重入锁，true为公平锁，false为非公平锁
    private final ReentrantLock lock = new ReentrantLock(true);
    //方法
    public void sale() {
        //上锁
        lock.lock();
        try {
            //判断票是否还有
            if (number > 0) {
                System.out.println(Thread.currentThread().getName()+"：卖出："+(number--)+"剩下："+number);
            }
        } finally {//finally 作用就是不管有没有异常最终都会实行finally里面代码
            //释放锁
            lock.unlock();
        }
    }
}
public class LockTest {
    public static void main(String[] args) {
        LTicket lticket = new LTicket();
        //创建线程
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程AA").start();

        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程BB").start();

        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                lticket.sale();
            }
        },"线程CC").start();
    }
}


```



## 读写锁 和 排它锁

排它锁，也就是说这些锁在同一时刻只允许一个线程访问

读锁：共享锁，发生死锁

写锁：独占锁，发生死锁

读写锁基本操作：

读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享。

```java
// resource class
class MyCache {
    // create a map collection
    private volatile Map<String,Object> map = new HashMap<>();
    // 创建读写对象
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    // put data
    public void put(String key,Object value){
        //添加写锁
        rwLock.writeLock().lock();
        // suspend or pause
        try {
            System.out.println(Thread.currentThread().getName()+"正在写操作"+key);
            TimeUnit.MICROSECONDS.sleep(300);
            // put data
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"写完了"+key);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            //释放锁
            rwLock.writeLock().unlock();
        }
    }
    //achieve data
    public Object get(String key){
        //添加读锁
        rwLock.readLock().lock();
        Object result = null;
        //suspend
        try {
            System.out.println(Thread.currentThread().getName()+"正在读取操作"+key);
            TimeUnit.MICROSECONDS.sleep(300);
            result = map.get(key);
            System.out.println(Thread.currentThread().getName()+"取完了"+key);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }
        return result;
    }
}
public class ReadWriteLockeDemo {
    public static void main(String[] args) {
        MyCache cache = new MyCache();
        // Create thread to release data
        for (int i = 1; i < 6; i++) {
            final int num = i;
            new Thread(() -> {
                cache.put(num+"",num+"");
            },String.valueOf(i)).start();
        }
        //create thread to get data
        for (int i = 1; i < 6; i++) {
            final int num = i;
            new Thread(() -> {
                cache.get(num+"");
            },String.valueOf(i)).start();
        }
    }
}
```

锁降级：

> 将写入锁降级为读锁
>
> JDK 8 说明：一个线程：获取写锁—>获取读锁 —> 释放写锁 —> 释放读锁（写锁-降级-读锁，读锁不能升级为写锁）

锁降级例子：

```java
public class LockDowngrade {
    public static void main(String[] args) {
        ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();    //read lock
        ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock(); //write lock
        //Lock Downgrade
        // 1 获取写锁
        writeLock.lock();
        System.out.println("Write....");
        // 2 获取读锁
        readLock.lock();
        System.out.println("Read......");
        // 3 Release read lock
        readLock.unlock();
        // 4 Release write lock
        writeLock.unlock();
    }
}
```

结果：

```java
output:
Write....
Read......
```



读锁不能升级为写锁

```java
public class LockDowngrade1 {
    public static void main(String[] args) {
        ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();    //read lock
        ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock(); //write lock
        //Lock Downgrade
        // 2 获取读锁
        readLock.lock();
        System.out.println("Read......");
        // 1 获取写锁
        writeLock.lock();
        System.out.println("Write....");
        // 3 Release read lock
        readLock.unlock();
        // 4 Release write lock
        writeLock.unlock();
    }
}
```

结果：

```java
output:
Read......
```

## CSA

自旋锁，由于线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说性能开销很大。同时，很多对象锁的锁定状态指会持续很短的时间，因此引入了自旋锁，所谓自旋就是一个无意义的死循环，在循环体内不断的重行竞争锁。当然，自旋的次数会有限制，超出指定的限制会升级到阻塞锁。



## 线程池（重要）

>  概念

线程池（thread pool）：是一种线程使用模式。线程过多会带来调度开销，进而影响缓存和整体性能。而线程池维护着多个线程，等待着监督管理者分配课并发执行任务。者避免了处理段时间任务创建与销毁线程的代价。线程池不仅能保证内核的充分利用还能防止过分调度。



> 为什么要用线程池？

（1）创建/销毁线程需要消耗系统资源，而线程池可以做到复用已创建的线程，从而降低系统资源的消耗。

（2）控制并发的数量。如果并发数量过多，可能会导致资源消耗过多，从而造成服务器崩贵。

（3）可以对线程的统一管理



> 4种常见的线程池及使用方式

* 一池N线程：Executors.newFixedThreadPool(int)

* 一个任务一个任务执行，一池一线：Executors.newSingleThreadExecutor()

* 线程池根据需求创建线程，可扩容，遇强则强：Executors.newCachedThreadPool()
* 创建一个定长线程池，支持定时和周期性任务执行：Executors.newScheduledThreadPool

创建：

```java
public class ThreadPoolDemo1 {
    public static void main(String[] args) {
        // 一池5个线程
        ExecutorService threadPool1 = Executors.newFixedThreadPool(5);
        // 一池一个线程
        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();
        //一池多个线程
        ExecutorService threadPool3 = Executors.newCachedThreadPool();
      
        ScheduledExecutorService threadPool4 = Executors.newScheduledThreadPool(2);
        // 10个顾客请求
        try {
            for (int i = 1; i < 11; i++) {
                //执行
                threadPool3.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPool3.shutdown();
        }
    }
}
```

**虽然四种常见线程池够使用了，但是一般我们没有去使用，而是使用《阿里巴巴开发手册》建议通过ThreadPoolExecutor的方式去使用，这样能够让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。**



> 为什么不建议使用Executors去类中线程池？

Executors创建的弊端：

* FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
* CachedThreadPool 和 ScheduleThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。





> 线程池原理

Java中的线程池最顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。

![Snip20210902_7.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gu2e36tmk3j30uc0m0tar.jpg)

ThreadPoolExecutor 提供了4个构成方法，大家可以点开源码看看就好了，以下说明构成方法中的参数代表意思：

```java
// 7个参数
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 
```

* int corePoolSize：核心线程数的最大值

* int maximumPoolSize：用于设置该线程池中线程总数最大值

* long keepAliveTime：表示非核心线程的存活时间（也就是说非核心线程处于闲置超过设定的值就会被销毁）

* TimeUnit unit：
* BlockingQueue<Runnable> workQueue：阻塞队列（维护等待线程的Runnable任务对象）
  * LinkedBlockingQueue（链式阻塞队列）
  * ArrayBlockingQueue（数组阻塞队列）
  * SynchronousQueue（同步队列）
  * DelayQueue（延迟队列）
* ThreadFactory threadFactory：线程工厂，主要用于批量创建线程（非必须）
* RejectedExecutionHandler handler：拒绝策略，用于设置当线程数量大于线程数就会采用拒绝处理策略。
  * ThreadPoolExecutor.AbortPolicy
  * ThreadPoolExecutor.DiscardPolicy
  * ThreadPoolExecutor.DiscardOldestPolicy
  * ThreadPoolExecutor.CallerRunsPolicy



> 通过ThreadPoolExecutor自定义线程池

自定义线程池：

```java
public class ThreadPoolDemo2 {
    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,
                5,
                2L,
                TimeUnit.MICROSECONDS,
                new ArrayBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        //处理10个顾客
        try {
            for (int i = 1; i <= 10; i++) {
                threadPoolExecutor.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPoolExecutor.shutdown();
        }
    }
}

```

> 线程池的execute核心方法

处理任务的核心方法是execute，以下是Java 11源码

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        // 判断当前线程数如果小于corePoolSize（核心线程最大值），则会调用addWorker创建核心线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 如果当前线程数大于corePoolSize，则会将任务添加到workQueue队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 如果放入workQueue（阻塞队列）失败，则创建非核心线程执行任务
        //如果创建非核心线程失败，那么就会执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
```

总结：

1、线程总数量 < 核心线程最大值(CorePoolSize)，无论线程是否空闲都会创建一个核心线程执行任务

2、线程总数量 >= 核心线程最大值(CorePoolSize)，新来的线程任务会进入阻塞队列等待，然后空闲的核心线程会依次去缓存队列中取出任务来执行。（需要索取全局锁）

3、如果缓存队列满了，说明这时候任务已经装不下了，那么需要临时工来执行这些任务，于是又会创建非核心线程去执行这个任务（需要索取全局锁）。如果缓存队列满了并且线程数量达到了MaxmumPoolSize时，则采取拒绝策略方式进行处理。



>ThreadPoolExecutor 如何做到线程复用？

addWorker源码：

```java
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (int c = ctl.get();;) {
            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    || firstTask != null
                    || workQueue.isEmpty()))
                return false;

            for (;;) {
                if (workerCountOf(c)
                    //如果core是ture，证明需要创建线程为核心线程，则先判断当前线程是否大
                    //如果core是false，证明需要创建非核心线程，则先判断当前线程数是否大
                    //如果不小于，则返回false
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateAtLeast(c, SHUTDOWN))
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
      boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 1.创建一个worker对象
            w = new Worker(firstTask);
           // 2.实例化一个Thread对象
            final Thread t = w.thread;
            if (t != null) {
                // 3.线程池全局锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();

                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        workerAdded = true;
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    // 4.启动该线程
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

总结：

1、首先做一个判断线程数量是否超出阈值，超出返回false

2、第二步才去创建worker对象

3、然后初始化Thread对象

4、最后启动该线程对象



> Worker 源码分析

```java
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    try {
                        //任务执行
                        task.run();
                        afterExecute(task, null);
                    } catch (Throwable ex) {
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

总结：

当执行完任务后，worker生命周期并没有结束，在while循环中，worker会不断调用getTask()方法从阻塞队列中获取renew然后调用task.run()执行任务（这就是达到复用线程的目的）



> getTask方法源码

```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();

            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            // allowCoreThreadTimeOut默认false，核心线程即使空也不会被销毁
            // 为true则核心线程在keepAliveTime内空闲就会被销毁
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            // 如果运行线程数量超过最大线程数，但缓存队列已经空，这时候递减worker数量
            // 如果有设置允许线程超过或者线程数量超过了核心线程数量，并且线程在规定时间内为Poll到任务且
            // 队列为空则递减worker数量
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

```



## 阻塞队列

```java
public class BlockingQueueDemo {
    public static void main(String[] args) {
        //创建阻塞队列
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        // 第一组
        System.out.println(queue.add("aa"));
        System.out.println(queue.add("bb"));
        System.out.println(queue.add("cc"));
        //System.out.println(queue.element());
        System.out.println(queue.remove());
        System.out.println(queue.remove());
        System.out.println(queue.remove());

    }
}
```



## 集合线程安全

1、ArrayList 线程不安全

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                //向集合中添加内容
                list.add(UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

**解决集合线程不安全方案**

> Vector、collections、CopyOnWriteArrayList

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        // 1 不安全
        //List<String> list = new Vector<>();
        // 2 通过vector解决，但是该方法很古老
        //List<String> list = new Vector<>();
        // 3 Collections
        List<String> list = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                //向集合中添加内容
                list.add(UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

以上方法都是很古老，可以解决，但实际开发很少使用，此时Javautil.concurrent包下提供CopyOnWriteArrayList用来解决。

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        // 4 CopyOnWriteArrayList
        List<Object> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                //向集合中添加内容
                list.add(UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

CopyOnWriteArrayList 解决原理：读是并发读，写时它会复制一份出来写完，在覆盖之前的文件，最终在读

2、HashSet线程不安全

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                //向集合中添加内容
                set.add(UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(set);
            },String.valueOf(i)).start();
        }
    }
}
```

报错：java.util.ConcurrentModificationException

**解决使用CopyOnWriteArraySet**

```java
Set<String> set = new CopyOnWriteArraySet<>();
```

3、HashMap线程不安全

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>();
        for (int i = 0; i < 10; i++) {
            String key = String.valueOf(i);
            new Thread(() -> {
                //向集合中添加内容
                map.put(key,UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
```

解决使用 ConcurrentHashMap

```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        Map<String,String> map = new ConcurrentHashMap<>();
        for (int i = 0; i < 10; i++) {
            String key = String.valueOf(i);
            new Thread(() -> {
                //向集合中添加内容
                map.put(key,UUID.randomUUID().toString().substring(0,8));
                //从集合中获取内容
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
```



