### 专业技能：

* 熟悉 Java 基础，多线程、深入学习过 ArrayList、HashMap、ConcurrentHashMap 等常用集合的源码
* 对 JVM 原理、垃圾收集机制、synchronized、Volatile 关键字的理解、乐观锁和悲观锁技术有一定了解
* 熟悉掌握 Spring MVC、MyBatis、Spring Boot 等主流框架，并能使用 maven 进行项目框架搭建
* 熟练 SQL 语言，并且熟悉使用 MySQL 数据库基本操作
* 熟悉使用 IDEA、及 Git 等工具使用；以及能进行 Linux、docker 基本操作

---

## Java基础和框架



## 多线程高并发

### 线程创建方式有哪些？

（1）继承Thread类创建线程

```java
public class MyThread extends Thread{
  //重写run方法
　　public void run(){
　　}
}
```

（2）实现Runnable接口创建线程

```java
public class MyThread2 implements Runnable {
　　public void run(){
　　//重写run方法
　　}
}
```

（3）使用Callable和Future创建线程

```java
public static class MyThread3 implements Callable{
    @Override
    public Object call() throws Exception {
        return 88;
    }
}
```

（4）使用线程池例如用Executor框架

线程启动方式有哪些？

线程状态？

### synchronized底层实现？

（1）Synchronized一般适用于以下几种场景：

* 修饰实例方法，锁是当前实例对象

  ```java
  public class Sync1 {
      public synchronized void test1(){
      }
  }
  ```

* 修饰静态方法，锁是当前类的Class对象

  ```java
  public class Sync2 {
      public void test2(){
          synchronized(Synchronized.class){
          }
      }
  }
  ```

* 修饰代码块，指定一个加锁的对象，给对象加锁

  ```java
  public class Sync3 {
      public void test3(){
          synchronized(new test()){
          }
      }
  }
  ```

  

  （2）synchronized底层的实现原理？

  synchronized底层的实现是基于monitorenter 和 monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处的，当线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。上面提高的monitorenter和monitorexit指令的底层是lock和unlock指令。

  （3）jdk1.6 synchronized做了哪些优化？

  Java 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁有4种状态从低到高：无锁-偏向锁-轻量级锁-重量级锁，锁的升级不可逆的，偏向锁在1.6之后是默认开启的，1.5中是关闭的，需要手动开启参数是xx:-UseBiasedLocking=false。

  （4）锁升级过程？

  偏向锁如果有线程竞争时，会发生偏向锁的撤销并升级为自旋锁。如果锁竞争情况严重，达到自旋锁默认10次数后(-XX：PreBlockSpin可以修改)，会升级为重量级锁。重量级锁就会去操作系统请求资源，相当于用户态变为内核态，系统开销大。

  

synchronized 和 Lock 区别？

* synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API
* synchronized会自动释放锁，而Lock必须手动释放锁
* synchronized是不可中断的，Lock可以中断也可以不中断
* synchronized能锁住方法和代码块，而Lock只能锁住代码块
* synchronized是非公平锁，ReentrantLock可以控制是否是公平锁

> synchronized缺点：在某些场景下我觉得锁升级过程是不可逆的缺点吧，比如滴滴打车，如果使用大量的synchronized，过了高峰值锁还是重量级锁，那效率就非常低，而且系统开销也很大。

### Volatile 关键字

Volatile是一个变量修饰符，只能用来修饰变量。volatile保证不同线程对共享变量操作的可见性，但不能保证原子性，如果当一个线程修改了volatile修饰的变量时，另一个线程立马可以看到。使用Volatile作用还可以禁止指令重新排序，

造成可见性原因？

在Java中造成可见性问题的原因是Java内存模型(JMM)，在Java内存模型中，规定了共享变量是存放在主内存中，然后每个线程都有自己的工作内存，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。volatile是如何保证可见性？有volatile修饰的共享变量进行写操作的时候多出一条带`lock前缀的指令`。

synchronized 和 volatile 区别？

* volatile只能修饰实例变量和类变量；synchronized可以修饰方法，以及代码块
* volatile保证数据的可见性，但不保证原子性；synchronized是一种排他(互斥)的机制
* volatile用于禁止指令重排序；

### 乐观锁和悲观锁

先聊一下CAS吧？

CAS（Compare And Swap 比较并且替换）是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。

CAS实现线程安全，当线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。

但是会出现一下问题：

* 如果CAS操作长时间不成功的话，会导致一直自旋，相当于死循环了，CPU的压力会很大。循环时间长开销大的问题

* 出现ABA问题：ABA问题就是指假如你有一个值，我拿到这个值是1，然后我使用CAS操作去修改这个值为2，在这个过程中，假如没有一个线程更改过这个值，我是可以成功修改为2的，但是如果有有一个线程先把这个1变成了2后来又变回1，中间值更改过，这就是ABA问题。解决：加标志位，任何一个值修改，修改完成后自增+1或者使用时间戳。

* 只能保证一个共享变量原子操作的问题

乐观锁的使用：比如多订单表，为了防止并发问题，我们就会加入CAS的校验过程。

聊聊悲观锁吧？

悲观锁的实现其实就是synchronized，可以保证同一时刻只有一个线程访问临界区。

那么它是如何保证线程安全的呢？

synchronized 对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：**对象头**（Header）、实例数据（Instance Data）和**对齐填充**（Padding）。**对象头**：我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。

当 Monitor 被某个线程持有后，就会处于锁定状态。如果synchronized 应用在同步块上时，在字节码中是通过 monitorenter 和 monitorexit 实现的。**同步方法和同步代码**块底层都是通过monitor来实现同步的



## 线程池

>  概念

线程池（thread pool）：是一种线程使用模式。线程过多会带来调度开销，进而影响缓存和整体性能。而线程池维护着多个线程，等待着监督管理者分配课并发执行任务。者避免了处理段时间任务创建与销毁线程的代价。线程池不仅能保证内核的充分利用还能防止过分调度。



> 为什么要用线程池？

（1）创建/销毁线程需要消耗系统资源，而线程池可以做到复用已创建的线程，从而降低系统资源的消耗。

（2）控制并发的数量。如果并发数量过多，可能会导致资源消耗过多，从而造成服务器崩贵。

（3）可以对线程的统一管理



> 4种常见的线程池及使用方式

* 一池N线程：Executors.newFixedThreadPool(int)

* 一个任务一个任务执行，一池一线：Executors.newSingleThreadExecutor()

* 线程池根据需求创建线程，可扩容，遇强则强：Executors.newCachedThreadPool()
* 创建一个定长线程池，支持定时和周期性任务执行：Executors.newScheduledThreadPool

创建：

```java
public class ThreadPoolDemo1 {
    public static void main(String[] args) {
        // 一池5个线程
        ExecutorService threadPool1 = Executors.newFixedThreadPool(5);
        // 一池一个线程
        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();
        //一池多个线程
        ExecutorService threadPool3 = Executors.newCachedThreadPool();
      
        ScheduledExecutorService threadPool4 = Executors.newScheduledThreadPool(2);
        // 10个顾客请求
        try {
            for (int i = 1; i < 11; i++) {
                //执行
                threadPool3.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPool3.shutdown();
        }
    }
}
```

**虽然四种常见线程池够使用了，但是一般我们没有去使用，而是使用《阿里巴巴开发手册》建议通过ThreadPoolExecutor的方式去使用，这样能够让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。**



> 为什么不建议使用Executors去类中线程池？

Executors创建的弊端：

* FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
* CachedThreadPool 和 ScheduleThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。





> 线程池原理

Java中的线程池最顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。

![Snip20210902_7.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gu2e36tmk3j30uc0m0tar.jpg)

ThreadPoolExecutor 提供了4个构成方法，大家可以点开源码看看就好了，以下说明构成方法中的参数代表意思：

```java
// 7个参数
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 
```

* int corePoolSize：核心线程数的最大值

* int maximumPoolSize：用于设置该线程池中线程总数最大值

* long keepAliveTime：表示非核心线程的存活时间（也就是说非核心线程处于闲置超过设定的值就会被销毁）

* TimeUnit unit：
* BlockingQueue<Runnable> workQueue：阻塞队列（维护等待线程的Runnable任务对象）
  * LinkedBlockingQueue（链式阻塞队列）
  * ArrayBlockingQueue（数组阻塞队列）
  * SynchronousQueue（同步队列）
  * DelayQueue（延迟队列）
* ThreadFactory threadFactory：线程工厂，主要用于批量创建线程（非必须）
* RejectedExecutionHandler handler：拒绝策略，用于设置当线程数量大于线程数就会采用拒绝处理策略。
  * ThreadPoolExecutor.AbortPolicy
  * ThreadPoolExecutor.DiscardPolicy
  * ThreadPoolExecutor.DiscardOldestPolicy
  * ThreadPoolExecutor.CallerRunsPolicy



> 通过ThreadPoolExecutor自定义线程池

自定义线程池：

```java
public class ThreadPoolDemo2 {
    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,
                5,
                2L,
                TimeUnit.MICROSECONDS,
                new ArrayBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        //处理10个顾客
        try {
            for (int i = 1; i <= 10; i++) {
                threadPoolExecutor.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+"办业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            threadPoolExecutor.shutdown();
        }
    }
}

```

> 线程池的execute核心方法

处理任务的核心方法是execute，以下是Java 11源码

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        // 判断当前线程数如果小于corePoolSize（核心线程最大值），则会调用addWorker创建核心线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 如果当前线程数大于corePoolSize，则会将任务添加到workQueue队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 如果放入workQueue（阻塞队列）失败，则创建非核心线程执行任务
        //如果创建非核心线程失败，那么就会执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
```

总结：

1、线程总数量 < 核心线程最大值(CorePoolSize)，无论线程是否空闲都会创建一个核心线程执行任务

2、线程总数量 >= 核心线程最大值(CorePoolSize)，新来的线程任务会进入阻塞队列等待，然后空闲的核心线程会依次去缓存队列中取出任务来执行。（需要索取全局锁）

3、如果缓存队列满了，说明这时候任务已经装不下了，那么需要临时工来执行这些任务，于是又会创建非核心线程去执行这个任务（需要索取全局锁）。如果缓存队列满了并且线程数量达到了MaxmumPoolSize时，则采取拒绝策略方式进行处理。



>ThreadPoolExecutor 如何做到线程复用？

addWorker源码：

```java
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (int c = ctl.get();;) {
            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    || firstTask != null
                    || workQueue.isEmpty()))
                return false;

            for (;;) {
                if (workerCountOf(c)
                    //如果core是ture，证明需要创建线程为核心线程，则先判断当前线程是否大
                    //如果core是false，证明需要创建非核心线程，则先判断当前线程数是否大
                    //如果不小于，则返回false
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateAtLeast(c, SHUTDOWN))
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
      boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 1.创建一个worker对象
            w = new Worker(firstTask);
           // 2.实例化一个Thread对象
            final Thread t = w.thread;
            if (t != null) {
                // 3.线程池全局锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();

                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        workerAdded = true;
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    // 4.启动该线程
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

总结：

1、首先做一个判断线程数量是否超出阈值，超出返回false

2、第二步才去创建worker对象

3、然后初始化Thread对象

4、最后启动该线程对象



> Worker 源码分析

```java
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    try {
                        //任务执行
                        task.run();
                        afterExecute(task, null);
                    } catch (Throwable ex) {
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

总结：

当执行完任务后，worker生命周期并没有结束，在while循环中，worker会不断调用getTask()方法从阻塞队列中获取renew然后调用task.run()执行任务（这就是达到复用线程的目的）



> getTask方法源码

```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();

            // Check if queue empty only if necessary.
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            // allowCoreThreadTimeOut默认false，核心线程即使空也不会被销毁
            // 为true则核心线程在keepAliveTime内空闲就会被销毁
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            // 如果运行线程数量超过最大线程数，但缓存队列已经空，这时候递减worker数量
            // 如果有设置允许线程超过或者线程数量超过了核心线程数量，并且线程在规定时间内为Poll到任务且
            // 队列为空则递减worker数量
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

```



## 