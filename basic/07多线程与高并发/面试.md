#### 什么是线程死锁？

就是多个线程同时被阻塞，他们都在等待某个资源释放。

#### 什么时候会产生死锁？

产生死锁的原因：互斥条件、不剥夺条件、请求与保持条件、循环等待条件

#### 如何避免线程死锁？

只要我们破坏产生死锁的4个条件的其中一个就可以。

破坏互斥条件、破坏请求与保持条件、破坏不可剥夺条件、破坏循环等待条件。

#### 说一下你对synchronized关键字的理解

### synchronized底层实现？

synchronized 关键字解决的是多个线程之间访问资源的同步性， synchronized 关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。在早起版本它是一个重量级锁，但是JDK 1.6 后有很大改变。

（1）Synchronized一般适用于以下几种场景：

* 修饰实例方法，锁是当前实例对象

  ```java
  public class Sync1 {
      public synchronized void test1(){
      }
  }
  ```

* 修饰静态方法，锁是当前类的Class对象

  ```java
  public class Sync2 {
      public void test2(){
          synchronized(Synchronized.class){
          }
      }
  }
  ```

* 修饰代码块，指定一个加锁的对象，给对象加锁

  ```java
  public class Sync3 {
      public void test3(){
          synchronized(new test()){
          }
      }
  }
  ```

  

  （2）synchronized 底层的实现原理？

  synchronized 底层的实现是基于 monitorenter 和 monitorexit 指令实现的。monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit是插入到方法结束处和异常处的，当线程执行到 monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。上面提高的monitorenter和monitorexit指令的底层是lock和unlock指令。

  （3）jdk1.6 synchronized做了哪些优化？

  Java 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁有4种状态从低到高：无锁-偏向锁-轻量级锁-重量级锁，锁的升级不可逆的，偏向锁在1.6之后是默认开启的，1.5中是关闭的，需要手动开启参数是xx:-UseBiasedLocking=false。

  （4）锁升级过程？

  偏向锁如果有线程竞争时，会发生偏向锁的撤销并升级为自旋锁。如果锁竞争情况严重，达到自旋锁默认10次数后(-XX：PreBlockSpin可以修改)，会升级为重量级锁。重量级锁就会去操作系统请求资源，相当于用户态变为内核态，系统开销大。

  

synchronized 和 Lock 区别？

* synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API
* synchronized会自动释放锁，而Lock必须手动释放锁
* synchronized是不可中断的，Lock可以中断也可以不中断
* synchronized能锁住方法和代码块，而Lock只能锁住代码块
* synchronized是非公平锁，ReentrantLock可以控制是否是公平锁

> synchronized缺点：在某些场景下我觉得锁升级过程是不可逆的缺点吧，比如滴滴打车，如果使用大量的synchronized，过了高峰值锁还是重量级锁，那效率就非常低，而且系统开销也很大。



### JMM（Java内存模型）



### Volatile 关键子