三次握手：通过三个包完成的

第一次握手：客户端向服务器发送一个seq(sequences)包请求服务器的某一个端口（没有带数据的）

第二次握手：服务器端响应时，发送ACK(Acknowledge)包和seq包

第三次握手：客户端返回ACK和序列号

## AbstractQueuedSynchronizer 之AQS

1、可重入锁又叫递归锁

是指在同一个线程在外层的方法获取锁后，再次进入 该线程内层方法会自动获取锁（前提你要锁对象是同一个对象）

Java 中 ReentrantLock 和 synchronized 都是可重入锁，可重入锁优点就是在一定程度避免死锁

可重入锁种类：

* 隐式锁：synchronized关键字使用的锁，默认可重入锁
* 显示锁：Lock，也有ReentrantLock

synchronized可重入锁种-同步代码块：

```java
public class ReentrantLock_ {
    static Object objectLock = new Object();
    public static void m1() {
        new Thread(() -> {
            synchronized (objectLock) {
                System.out.println(Thread.currentThread().getName() + "\t" + "outer layer ...");
                synchronized (objectLock) {
                    System.out.println(Thread.currentThread().getName() + "\t" + "middle layer ...");
                    synchronized (objectLock) {
                        System.out.println(Thread.currentThread().getName() + "\t" + "core layer ...");
                    }
                }
            }
        },"t1").start();
    }
    public static void main(String[] args) {
        m1();
    }
}
```

synchronized可重入锁种-同步代方法：

```java
public class ReentrantLock__ {
    public synchronized static void m1() {
        System.out.println("outer...");
        m2();
    }
    public synchronized static void m2() {
        System.out.println("middle ...");
        m3();
    }
    public static synchronized void m3() {
        System.out.println("core ...");
    }
    public static void main(String[] args) {
        m1();
    }
}
```

Lock

```java
public class ReentrantLock_1 {
    static Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        new Thread(() -> {
            lock.lock();
            lock.lock();
            lock.lock();
            try {
                System.out.println("外层");
                lock.lock();
                try {
                    System.out.println("中层");
                    lock.lock();
                    try {
                        System.out.println("内层");
                    } finally {
                        lock.unlock();
                    }
                } finally {
                    lock.unlock();
                }
            } finally {
                // 要两两使用，否则出现死锁
                lock.unlock();
                lock.unlock();
                lock.unlock();
            }
        },"t1").start();
        new Thread(() ->{
            lock.lock();
            try {
                System.out.println("t2开始");
            } finally {
                lock.unlock();
            }
        },"t2").start();
    }
}
```

2、LockSupport

LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。

线程等待唤醒机制（wait/notify）这是传统的synchronized 和 Lock实现等待唤醒通知的约束，如果去掉同步代码块会有异常java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method)。使用wait/notify都必须在synchronized内部执行，如果我们将 notify放在wait方法前面程序无法执行，无法唤醒的。

```java
public class ReentrantLock_1 {
    static Lock lock = new ReentrantLock();
    public static void main(String[] args) {
        new Thread(() -> {
            lock.lock();
            lock.lock();
            lock.lock();
            try {
                System.out.println("外层");
                lock.lock();
                try {
                    System.out.println("中层");
                    lock.lock();
                    try {
                        System.out.println("内层");
                    } finally {
                        lock.unlock();
                    }
                } finally {
                    lock.unlock();
                }
            } finally {
                // 要两两使用，否则出现死锁
                lock.unlock();
                lock.unlock();
                lock.unlock();
            }
        },"t1").start();
        new Thread(() ->{
            lock.lock();
            try {
                System.out.println("t2开始");
            } finally {
                lock.unlock();
            }
        },"t2").start();
    }
}

```

LockSupport 类中的park 等待和unpark唤醒，使用

```java
public class LockSupport_ {
    public static void main(String[] args) {
        Thread a = new Thread(() -> {
            try {Thread.sleep(3000);} catch (InterruptedException e) {e.printStackTrace();}
            System.out.println(Thread.currentThread().getName() + "\t" + "come in");
            LockSupport.park();
            System.out.println(Thread.currentThread().getName() + "\t" + "A线程被唤醒");
        }, "A线程");
        a.start();
        Thread b = new Thread(() -> {
            LockSupport.unpark(a); 
            System.out.println(Thread.currentThread().getName() + "\t" + "通知");
            //LockSupport.unpark(a);//也OK
        }, "B线程");
        b.start();
    }
}
```

LockSupport底层源码：LockSupport是用来创建和其他同步类的基本线程阻塞原语。是一个线程阻塞工具类，所有方法都是静态方法。底层是调用Unsafe中的native方法。

LockSupport提供park和unpark方法来实现阻塞线程和解除线程阻塞的过程。

每个线程使用LockSupport时其实就是使用许可证permit关联的：

* 调用一次unpark就加1，最多就一个许可证1
* 调用一次park会消费1，同时park立即返回。

源码

```java
public static void park() {
        U.park(false, 0L);
    }
```

3、AQS（抽象队列同步器）

概念：AQS是用来构建锁和者其他同步器组建的重要级基础框架及整个JUC体系的基石，通过内置的FIFO队列来完成资源获取的队列工作，并通过一个int类型变量来表示持有锁的状态。其实底层就是一个state状态位。

AQS能干嘛？





## Spring 源码

AOP 常用注解

| 注解           | 说明                             |
| :------------- | -------------------------------- |
| @Before        | 前置通知：目标方法之前执行       |
| @After         | 后置通知：目标方法之后执行       |
| @AfterReturing | 返回后置通知：执行方法结束前执行 |
| @AfterThrowing | 异常通知：出现异常时候执行       |
| @Around        | 环绕通知：环绕目标方法执行       |

Spring 源码

```java
<b>第一级缓存</b>
new ConcurrentHashMap<>(256);
<b>第二级缓存</b>
new HashMap<>(16);
<b>第三级缓存</b>
new HashMap<>(16);
```

Spring 执行流程：程序猿写的[xml&注解]—>通过(BeanDefinitionReader)解析 —> 解析到的内容存放到档案库里面(Map)—> 把Bean定义的信息名字[进行对象的创建]



## Redis

#### 1、你说一下Redis有哪些常见类型？

快速回答：**string**、**list**、**hash**、**set**、**zset**五种常见数据类型，我相信几乎谁都知道吧。

但是，如果你要大部人脱颖而出突出与其他人不同，你是不是都来点不一样的呢？那是必须的，还需要加上这几种数据结构**bitmap、HyperLogLog、Geo、Pub/Sub、stream**。

如果你还想加分，那你说还玩过**Redis Module**，像**BloomFilter，RedisSearch，Redis-ML，**这个时候面试官得眼睛就开始发亮了，心想这个小伙子**有点东西啊**。

> String字符类型、Hash散列类型、List列表类型、Set集合类型、Zset有序集合类型、Bitmap位图、HyperLogLog统计、GEO地理、Stream流（用于对日志数据结构进行建模）

Redis数据结构应用场景：

> 细节：Redis命令不区分大小写，但是key是区分的；help命令帮助你对哪些不熟悉的命令:`127.0.0.1:6379> help @string`

**（1）String场景**：商品编号、订单号采用INCR命令生成、点赞数、文章阅读量这些

**（2）Hash场景**：购物车

```
# shopcar:uid101淘宝的购物车，2048是你加入购物车的商品ID，1表已加入购物，0就没有加入
hset shopcar:uid101 2048 1
# 添加商品数量，表示添加数量
hincrby shopcar:uid101 2048 1
```

**（3）List场景**：发布与订阅及消息队列、慢查询。（比如微信文章公众号）

**（4）Set场景**：无序无重复。（重要喔社交类的网站）

复习基本操作：

* 添加元素：sadd key member
* 删除元素：srem key member
* 获取集合所有元素：smembers key
* 判断元素是否在集合：sismember key member
* 获取集合中的元素个数：scard key
* 从集合中随机弹出一个元素，元素不删除：srandmember key 2[你想随机抽出几个]
* 从集合中随机弹出一个元素，出一个删除一个：spop set01 2[你想随机抽出几个]

* 集合的差集：属于A但不属于B的元素构成集合（sdiff key）
* 集合的交集：sinter key
* 集合的并集：sunion key

场景：

* 微信抽奖小程序

![Snip20211002_36.png](http://ww1.sinaimg.cn/large/006FuVcvgy1gv0s91j6r8j60my0pegqt02.jpg)

|         功能         |                         对应使用命令                         |
| :------------------: | :----------------------------------------------------------: |
| 用户ID，按“点击参与” |                       sadd key 用户ID                        |
| 显示“已有3804人参与” |                      Scard key（统计）                       |
|   抽奖“一二三等奖”   | spop key 3（随机抽奖3个人，获得奖者后就删除）；srandmember key 2（随机抽奖2人，元素不删除） |

* 微信朋友圈点赞：点赞就是添加，取消就是删除
* 微博好友关注社交关系：如共同关注的人（求交集）
* QQ内推可能认识的人：差集运算（sdiff key1 key2：表示key2可能认识key1的人；反之sdiff key2 key1）

**（5）Zset场景**：

基本操作命令：

* 向有序集合加入一个元素和该元素的分数：add key score member [score member...]
* 按照元素大小从小-大排序
* 返回索引start-stop之间元素：zrange key start stop
* 获取元素的分数：zscore key [member ...]
* 删除元素：zrem key member [member ...]
* 获取指定分数范围的元素：zrangebyscore key min max 【 withscores 】【limit offset count】
* 增加某个元素的分数：zincrby key increment member
* 获取集合中元素的数量：zcard key
* 获取指定分数范围内元素个数：zcount key min max
* 按照排序名范围删除元素：zremrangebyrank key start stop

场景：

* 商品销量排行榜，案例如下：

|                        案例                        |               操作命令                |
| :------------------------------------------------: | :-----------------------------------: |
|      商品编号101销量为8，商品编号102销量为90       |   zadd goods:sellsort 9 101 90 102    |
| 如有客户买了5件商品101，那么我们在编号101销量增加5 |     zincrby goods:sellsort 5 101      |
|                  求商品销量前10名                  | zrange goods:sellsort 0 10 withscores |

* 抖音、微博等热搜榜

---

**（6）bitmap**：

概念：bitmap称为位图，1个字节(1byte)=8位(8bit)，1个byte有8个bit，每个小格子只能存放0或1，用来判断Y/N状态。当存入超过8位也就是等于一个字节(1byte)就再次扩容一组为8位的一个字节。（使用type x查看底层string类型，实质对应的是二进制ASCII编码）

Bitmap支持的最大位数是2^32位，他可以极大节约存储空间，使用512M内存就可以多达42.9亿字节信息。

场景：登录状态统计Y/N（每次签到）、签到统计、上班打卡、电影广告是否被点击过

案例：日活量、京东签到送豆豆（登录签到就是1，未签到为0）

基本命令：

| 命令                        |                       作用                       | 时间复杂度 |
| :-------------------------- | :----------------------------------------------: | :--------: |
| Setbit key offset val       |           给指定key的值的第offset赋值            |    O(1)    |
| Getbit key offset           |             获取指定key的第offset位              |    O(1)    |
| Bitcount key start end      |       返回指定key中[start,end]中为1的数量        |    O(n)    |
| Bitop operation destkey key | 对不同的二进制存储数据进行位运算(and/or/not/xor) |    O(n)    |
| Strlen                      |            取出字节长度（8bit=1byte）            |            |
|                             |                                                  |            |

案例：要求员工月活统计功能。

假设某员工(sing:u1:202110)在1-5、25、30号来打卡设置如下，然后统计出来

```redis
# 1号来设为状态为1
127.0.0.1:6379> setbit sing:u1:202110 1 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 2 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 3 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 4 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 5 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 25 1
(integer) 0
127.0.0.1:6379> setbit sing:u1:202110 30 1
(integer) 0
# 统计，类似mysql的select count(*)
127.0.0.1:6379> bitcount sing:u1:202110
(integer) 7
127.0.0.1:6379> type sing:u1:202110
string
```





#### 2、分布式锁

你了解分布式锁吗？

> 问题：
>
> * Redis除了拿来做缓存，还可以怎么用呢？
> * Redis做分布式锁时候有需要注意哪些问题？
> * 如果redis是单点部署，会带来哪些问题？你如解决单点问题？
> * 集群模式下，比如主从模式，有没有什么问题？
> * 那你简单介绍一下Redlock？你简历上写redisson是什么？
> * Redis分布式锁如何续期？看门狗知道吗？

分布式锁使用场景：多个服务键+保证同一时刻内+同一用户只能有一个请求（防止关键业务出现数据冲突和并发错误）











---

#### 3、Redis 缓存过期策略？

（1）如何查看Redis最大占用内存？通过配置文件，默认是使用最大内存的的。

（2）一般生产上你如何配置？Redis推荐配置为最大物理内存的四分之三。（0.75）

（3）你如何设置Redis内存大小？通过配置文件或者命令的方式

配置文件：

```redis
# maxmemory <bytes> 注意转换
maxmemory 104857600
```

命令行方式：

```redis
config get maxmemory    #查看Redis内存大小
config set maxmemory 1  #设置
```

还有可以通过：`info memory`

（4）如果Redis内存满了会出现什么情况？**会出现OOM**

面试问你这个问题，其实它是想问你，当Redis满了之后，如何避免类似情况呢？此时引出内存淘汰策略。

（5）Redis 缓存淘汰策略

Redis内存淘汰策略，默认有8种。

**Redis**的过期策略，是有**定期删除+惰性删除**两种

* 定时删除：对CPU不友好，用处理器性能换取存储空间
* 懒性删除：对内存不友好，用存储空间换取处理性能
* 定期删除：指定每隔一段时间执行一次删除过期键操作，采用随机抽取的策略，利用过期数据占比的方式控制删除频度，会导致很多Key到过期时间并没有被删除。

上面都有缺点，此时我们使用Redis提供的8种内存淘汰策略，本次学习版本6.2.5：

* noeviction：不会驱逐任何Key
* allkeys-lru：对所有Key使用LRU算法进行删除
* volatile-lru：对所有设置过期时间的Key使用LRU算法进行删除
* allkeys-random：对所有Key随机删除
* volatile-random：对所有设置了过期时间的Key随机删除
* volatile-ttl：删除马上要过期的Key
* allkeys-lfu：对所有Key使用LFU算法进行删除
* volatile-lfu：对所有设置了过期时间的Key使用LFU算法进行删除

> LRU means Least Recently Used #最近最少使用（时间上）
>
> LFU means Least Frequently Used #最近最少使用（频率度）

连环问：你公司使用哪一种？或你平时使用哪一种？

一般使用`allkeys-lru`，如何配置呢？通过配置文件`maxmemory-policy allkeys-lru`，或命令行方式：`config set maxmemory-policy allkeys-lru `

常见缓存淘汰算法： **FIFO** 先进先出、**LRU** 最近最少、和 **LFU** 最近使用频率最低

什么是LRU算法？

最近最少使用的数据给以淘汰，是一种常用的页面置换算法。LRU核心思想：哈希双向链表实现

[官网地址](https://leetcode-cn.com/problems/lru-cache/)

方式1:使用最快方式写

```java
public class LRUCache<K,V> extends LinkedHashMap {
    private int capacity; // 容量大小，也就是缓存允许最大数量
    public LRUCache(int capacity) {
        super(capacity,0.75F,true);
        this.capacity = capacity;
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return super.size() > capacity;
    }
    public static void main(String[] args) {
        LRUCache lruCache = new LRUCache(3);
        lruCache.put(1,"a");
        lruCache.put(2,"b");
        lruCache.put(3,"c");
        System.out.println(lruCache.keySet());
        lruCache.put(4,"d");
        System.out.println(lruCache.keySet());
    }
}
```

方式2:面试官说，不允许使用LinkedHashMap，请你手写一个。

> 你是否可以在 `O(1)` 时间复杂度内完成这两种操作？

首先我们想到使用HashMap确定查找，双向链表模拟AQS

```java
public class LRUCache_2 {
    /**
     * map负责查找，构建一个虚拟的双向链表，它里面安装的就是一个Node节点，作为数据载体
     * 1，构建一个Node节点，作为数据载体
     * @param <K>
     * @param <V>
     */
    class Node<K,V> {
        K key;
        V value;
        Node<K,V> prev; // 前缀
        Node<K,V> next; // 后缀
        public Node() {
            // 将前后缀初始化为null
            this.prev = this.next = null;
        }
        public Node(K key, V value) {
            this.key = key;
            this.value = value;
            this.prev = this.next = null;
        }
    }

    // 构建一个双向队列，里面安装就是我们的Node
    class DoubleLinkedList<K,V> {
        Node<K,V> head; //头节点
        Node<K,V> tail; //尾节点
        public DoubleLinkedList() {
            head = new Node<>();
            tail = new Node<>();
            // 头尾连接构成双向链表
            head.next = tail;
            tail.prev = head;
        }
        // 添加到头
        public void addHead(Node<K,V> node) {
            node.next = head.next;
            node.prev = head;
            head.next.prev = node;
            head.next = node;
        }
        // 删除节点
        public void removeNode(Node<K,V> node) {
            node.next.prev = node.prev;
            node.prev.next = node.next;
            node.prev = null;
            node.next = null;
        }
        // 获取
        public Node getLast() {
            return tail.prev;
        }
    }
    private int cacheSize;
    Map<Integer, Node<Integer,Integer>> map;
    DoubleLinkedList<Integer,Integer> doubleLinkedList;

    public LRUCache_2(int cacheSize) {
        this.cacheSize = cacheSize;
        map = new HashMap<>();
        doubleLinkedList = new DoubleLinkedList<>();
    }
    public int get(int key) {
        if (!map.containsKey(key)) {
            // 如果不存在就返回-1
            return -1;
        }
        Node<Integer, Integer> node = map.get(key);
        doubleLinkedList.removeNode(node);
        doubleLinkedList.addHead(node);
        return node.value;
    }
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node<Integer, Integer> node = map.get(key);
            node.value = value;
            map.put(key,node);
            doubleLinkedList.removeNode(node);
            doubleLinkedList.addHead(node);
        } else {
            if (map.size() == cacheSize) {
                Node<Integer,Integer> last = doubleLinkedList.getLast();
                map.remove(last.key);
                doubleLinkedList.removeNode(last);
            }
            // 新增
            Node<Integer, Integer> newNode = new Node<>(key, value);
            map.put(key,newNode);
            doubleLinkedList.addHead(newNode);
        }
    }
    public static void main(String[] args) {
        LRUCache_2 lruCache = new LRUCache_2(3);
        lruCache.put(1,1);
        lruCache.put(2,2);
        lruCache.put(3,3);
        System.out.println(lruCache.map.keySet());
        lruCache.put(4,4);
        System.out.println(lruCache.map.keySet());
    }
}
```

