> 别人可以，为什么我不可以？

## 一、并发安全关键字

#### 谈一谈你对 Volatile 的理解

Volatile 是java虚拟机提供的**轻量级的同步机制**，它可以使在多线程共享变量时的**保证可见性**，及**禁止指令重排**，但是**不保证原子性**的。

> 解答上面三个特性后，面试官可能会引入：什么是可见性？为什么要禁止指令重排？那如何做到保证原子性？那你在哪些地方使用过Volatile？



聊 Volatile 我们首先科普 JMM 知识？

JMM 是 Java内存模型，和 JVM（Java虚拟机） 不是一回事的喔。JMM(Java内存模型Java Memory Model，简称JMM) 本身是一种抽象的概念并不是真实存在。它描述一种规则或规范。通过这组规范定义程序中各种变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定：

1. 线程解锁之前，必须把共享变量的值刷新回主内存中
2. 线程加锁前，必须读取主内存的最新值到自己的工作区内存中
3. 加锁解锁是同一把锁

JMM 特性：可见性、原子性、有序性

**验证`Volatile`保证可见性**：

> 大家看下面代码，运行后永远都没有输出`我还是傻傻的等着你！`，此时加上`Volatile`关键字就可以解决了。

![Snip20210927_26.png](http://ww1.sinaimg.cn/large/006FuVcvgy1guui3i8979j61hq124h0o02.jpg)

总结：可见性就是，一个线程修改去主内存的值，主内存的值只要被修改，其他线程马上得到通知。

**验证 Volatile 不保证原子性**：

> 什么是原子性？是指某个线程去做某个具体业务时，中间不可以被分割。**要么同时成功，要么同时失败**。

![Snip20210927_27.png](http://ww1.sinaimg.cn/large/006FuVcvgy1guvfuzmfrpj618g12oqh702.jpg)

如何解决原子性：`synchronized`，但是我们不是为了`number++`而使用`synchronized`，太重了。那我们使用什么呢？`atomic` 下面正式我们了解的。atomic底层实现是CAS，而CAS底层是unsafe类实现。

```java
AtomicInteger atomicInteger = new AtomicInteger();
    public void addAtomic() {
        atomicInteger.getAndDecrement();
    }
```

> 什么是指令重排？

指令重排，假如我们源代码写着1、2、3，底层为了保证执行效果性能更好，所以它不会按照我们写的1、2、3一条条执行。而使用Volatile可以禁止指令重排。

那在什么情况下要考虑指令重排问题？在多线程环境下线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，但是单线程环境不需要指令重排问题的。

> 那你在哪些地方使用过Volatile？单例使用的

单例模式

```java
public class SingletonDemo {
    private /*volatile*/ static SingletonDemo instance = null;
    private SingletonDemo() {
        // 主要验证是否被多次
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo()");
    }
    public static SingletonDemo getInstance() {
        if (null == instance){
            synchronized (SingletonDemo.class) {
                if (null == instance) {
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
    public static void main(String[] args) {
        // 单线程
        //System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        // 并发情况
        for (int i = 0; i < 10; i++) {
            new Thread(() ->{
                SingletonDemo.getInstance();
            },String.valueOf(i)).start();
        }
    }
}
```

双端检锁不使用 Volatile 关键字线程安全吗？不一定安全，因为是有指令重排的存在，原因在某一个线程执行到第一次检测时，读取到instance不为null，instance的引用对象可能没有完成初始化。（instance = new SingletonDemo();需要三步才完成。第一分配对象内存空间；第二初始化对象；第三设置instance指向刚分配的内存地址，但是如果不使用volatile，可能出现先分配对象内存，然后直接设置instance分配地址，但没有初始化，此时多线程情况可能会出现取到空的实例）

总结：

> 当对Volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存的共享变量值刷新回到主内存中。
>
> 当对Volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。
>
> volatile的底层是通过**内存屏障**实现的，作用是**禁止指令重排**。内存屏障另一个作用是**强制更新一次不同 CPU 的缓存**。而synchronized 底层的实现是基于 monitorenter 和 monitorexit 指令实现的。



#### CAS 知道吗？谈谈你的理解？

cas是：比较交换，是CPU并发原语。

> 假设现在有A和B两个线程同时去操作主内存中共享变量，比如该值为5吧。A、B现在要去操作必须读回自己的工作内存区才能进行操作的。现在A线程调用getIntVolatile拿到5这个值了，这时候挂起，然后B线程getIntVolatile拿到5这个值，成功修改为6，然后刷新回主内存中，这时候主内存的值已经被B线程修改6了。然后这时候A线程恢复了，然后执行weakCompareAndSetInt方法去和主内存进行比较，发现自己的值和主内存不一样，说明该值被别的线程修改了，那么A线程修改失败，只能重写读取主内存的新值到自己工作内存区再次修改。这就是比较交换。CAS的缺点就是ABA问题。ABA问题就是一直自旋，一直得不到。

底层原理：最核心底层是调用unsafe类的是原生类，由于CAS是一种系统原语，最最底层就是CAS是CPU的原子指令，所以不会造成数据的不一致性，从而保证原子性，因此线程安全。

源码

```java
public final int getAndDecrement() {
        return U.getAndAddInt(this, VALUE, -1);
    }
//VALUE偏移量
public final int getAndDecrement() {
        return U.getAndAddInt(this, VALUE, -1);
    }
public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!weakCompareAndSetInt(o, offset, v, v + delta));
        return v;
    }
```

CAS缺点？

* 循环时间长开销很大，因为它需要多次比较，如果一直自旋还是不成功，那么就出现ABA问题。

* 还能保证一个共享变量的原子操作
* ABA 问题

谈谈原子类 AtomicInteger 的ABA问题？原子更新引用知道吗？

> 面试官：CAS -> Unsafe -> CAS底层思想 -> ABA问题 -> 原子引用更新 -> 如何避免ABA问题？

ABA是如何产生的？

CAS 的缺点就是“ABA”问题，CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较替换，那么在这个时间差会导致数据的变化。

解决ABA问题：原子引用(AtomicStampedReference)  和 加版本号



## 二、集合复习

#### 1、集合不安全？ArrayList

问题：

（1）故障现象：

```java
java.util.ConcurrentModificationException
```

（2）导致原因

（3）解决方案

解决方案：

* **Vector **，如果不用Vector怎么解决？

* 使用**Collections**即可解决，如下代码

```java
List<String> list  = Collections.synchronizedList(new ArrayList<>());
```

* 如果面试官也不想用Collections呢？此时解决是什么？使用JUC包下的**CopyOnWriteArrayList**

```java
// java.util.concurrent 简称JUC
import java.util.concurrent.CopyOnWriteArrayList;
```

CopyOnWriteArrayList 底层剖析：

CopyOnWriteArrayList 底层是实现List的，底层也是object[]数组，被Volatile关键字修饰。添加原理也是和ArrayList一样的底层是Arrays.copyOf内部调用System.arraycopy。

总结：

> CopyOnWrite容器写时复制的容器。当往容器添加元素时候，它不直接往当前的Object[]添加的，而是先将当前容器Object[]进行复制(Copy)，复制出一份新容器Object[] newElments,然后新的容器Object[] newElements 里添加元素，添加完元素，在将原容器的引用指向新的容器setArray(newElements);，这样好处就是可以对CopyOnWrite容器进行并发读，而不需要加锁，也是一种读写分离的思想，读写在不同容器的。

（4）优化建议

#### 2、线程不安全？HashSet

HashSet线程不安全的，会出现并发异常`java.util.ConcurrentModificationException`

解决：

* Collections.synchronizedSet

* CopyOnWriteArraySet

HashSet底层：

底层实现是HashMap的，在调用add()方法时，底层是put()方法实现的，当我们添加一个元素时，是作为put()方法的Key值，而Value是一个PRESENT的Object[]数组类型的常量。

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
```

#### 3、线程不安全？HashMap

使用HashMap是线程不安全的，会出现`java.util.ConcurrentModificationException`。

解决：ConcurrentHashMap 或 Collections.synchronizedMap



## 三、Java 锁

#### 1、公平锁 和 非公平锁

公平锁：是指多个线程按照申请锁的顺序来获取锁，先来后到

非公平：是指多个线程获取锁的顺序并不是按照申请锁的顺序来的，获取锁在高并发的情况下，有可能会造成优先级反转或者饥饿现象。synchronized和ReentrantLock是一个典型的可重入锁，默认是非公平锁的。

```java
Lock lock = new ReentrantLock();
```

#### 2、可重入锁 和 递归锁

可重入锁也叫递归锁，指在同一线程外层函数获得锁之后，内层递归函数仍能获得该锁的代码。在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它拥有的锁所同步着代码块。synchronized和ReentrantLock是一个典型的可重入锁，默认是非公平锁的。

synchronized 代码验证可重入锁：

```java
class t3 {
    public synchronized void sendSMS() {
        System.out.println(Thread.currentThread().getId() + "\t sendSMS");
        sendEmail();
    }
    public synchronized void sendEmail() {
        System.out.println(Thread.currentThread().getId() + "\t sendEmail");
    }
}
public class T2 {
    public static void main(String[] args) {
        t3 t3 = new t3();
        new Thread(() -> {
            t3.sendSMS();
        },"t1").start();
        new Thread(() -> {
            t3.sendSMS();
        },"t2").start();
    }
}
```

ReentrantLock代码验证可重入锁:

#### 3、自旋锁

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点就是循环会消耗CPU。

#### 4、独占锁(写锁)和共享锁(读锁)

独占锁：指该锁一次只能被一个线程所持有，对于ReentrantLock和synchronized而言都是独占锁。

共享锁：指该锁可被多个线程所持有。对于ReentrantReadWriteLock其读锁是共享的，其写锁是独占锁。

> 读读-能共享、读写-不能共享、写写-不能共享

> try catch快捷键:option+command+t、

手写读写锁代码：

```java
class MyCache {
    private volatile Map<String,Object> map = new HashMap<>();
    // 可重入读写锁
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    public void put(String key,Object value) {
        rwLock.writeLock().lock();//写锁
        try {
            System.out.println(Thread.currentThread().getName()+"\t 正在写入：" + key);
            try{TimeUnit.MICROSECONDS.sleep(300);}catch (InterruptedException e) {e.printStackTrace();}
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"\t 写入完成：");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.writeLock().unlock();//释放锁
        }
    }
    public void get(String key) {
        rwLock.readLock().lock();//读锁
        try {
            System.out.println(Thread.currentThread().getName()+"\t 正在读取：");
            try{TimeUnit.MICROSECONDS.sleep(300);}catch (InterruptedException e) {e.printStackTrace();}
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName()+"\t 读取完成：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        // 设置5个线程写
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() ->{
                myCache.put(tempInt + "",tempInt+"");
            },String.valueOf(i)).start();
        }
        // 设置5个线程读
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() ->{
                myCache.get(tempInt+"");
            },String.valueOf(i)).start();
        }
    }
}

```

## 四、并发工具类

#### 1、CountDownLatch

它是能够让一些线程阻塞直到另一个线程完成一系列操作后才被唤醒。CountDownLatch 主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞，其他线程调用countDown方法会将计数器减1（调用countDown时不会使线程阻塞的），当计数器的值变为0时，因调用await方法被阻塞的线程会被唤醒，继续执行。

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws Exception{
        CountDownLatch countDownLatch = new id(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(() ->{
                System.out.println(Thread.currentThread().getName()+"\t 上完自习，离开教室");
                countDownLatch.countDown();
            }).start();
        }
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName()+"\t 完成锁住OK");
    }
}
//结果
Thread-0	 上完自习，离开教室
Thread-5	 上完自习，离开教室
Thread-2	 上完自习，离开教室
Thread-3	 上完自习，离开教室
Thread-1	 上完自习，离开教室
Thread-4	 上完自习，离开教室
main	 完成锁住OK
```

> 小总结：CountDownLatch是做减法的，初始值是多少，会减到0。

#### 2、CyclicBarrier

和CountDownLatch相反的，初始值为0做加法的。（开会需要10人，当人到齐你才能开会）CyclicBarrier的字面是可循环(Cyclic)使用的屏障(Barrier)。主要是做让一组线程达到一个屏障或叫同步点时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。

两个方法

```java
//设置最高达到7，阻塞线程
CyclicBarrier(int parties, Runnable barrierAction)
```

栗子

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        // 使用Java8新特性
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() ->{System.out.println("------召唤神龙-------");});
            for (int i = 1; i < 8; i++) {
                final int tempInt = i;
                new Thread(() ->{
                    System.out.println(Thread.currentThread().getName()+"\t收集到第"+ tempInt +"龙珠");
                    try {
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                },String.valueOf(i)).start();
            }
    }
}
```

#### 3、Semaphore（信号量）重要

> 尤其支付接口，及秒杀大量使用（可以代替synchronized和lock）

信号量主要用于两个目的，一是用于多个共享资源的互斥，二用于并发线程数的控制。（多对多）底层默认非公平锁。

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);//3个停车位
        for (int i = 1; i <= 6; i++) {//模拟6辆车，去抢3个停车位
            new Thread(() ->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);//每车停3秒
                    System.out.println(Thread.currentThread().getName()+"\t 停车3秒");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //释放锁（释放车位）
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

#### 4、阻塞队列（BlockingQueue）接口

什么事阻塞队列？是指当队列是空时，从队列中获取元素的操作将会被阻塞；当阻塞队列是满时，往队列里添加元素操作会被阻塞。

在多线程领域：所谓阻塞，在某种情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒。

为什么要BlockingDeque？使用好处就是不需要去关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingDeque都会给你一手包办了。（手动车变为自动车）

BlockingDeque：

* **ArrayBlockingQueue**：由数组结构组成的有界阻塞队列
* **LinkedBlockingQueue**：由链表结构组成的有界阻塞队列（大小默认为Inter.MAX_VALUE）
* **SynchronizedQueue**：不存储元素的阻塞队列，页即单个元素的队列(同步队列：只要你不消费，我就不生产)
* PriorityBlockingQueue：使用优先级排序的无界阻塞队列
* DelayQueue：使用优先级队列实现的延迟无界阻塞队列
* LinkedBlockingQueue：由链表结构组成的无界阻塞队列
* LinkedTransferDeque：由链表结构组成的双向链表阻塞队列

核心方法：

| 方法类型 | 抛出异常  |  特殊值  |  阻塞  |        超时         |
| :------: | :-------: | :------: | :----: | :-----------------: |
|   插入   |  Add(e)   | Offer(e) | Put(e) | Offer(e, time,unit) |
|   移除   | Remove()  |  Poll()  | Take() |  Poll(time, unit)   |
|   检查   | Element() |  Peek()  |   \    |          \          |

当超出队列限制大小会抛异常：`Queue full`

当阻塞队列空时，再往队列里删除元素会抛出：`NoSuchElementException`

#### 5、生产者消费者

传统方式：

```java
class ShareDate {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void increment() throws Exception {
        try {
            // 1、判断（多线程的判断一定要while，if是有问题的）
            while (number != 0) {
                //等待
                condition.await();
            }
            // 2、++操作
            number++;
            System.out.println(Thread.currentThread().getName()+"\t" + number);
            // 3、通知唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void decrement() throws Exception {
        try {
            // 1、判断
            while (number == 0) {
                //if number==0说明里头没有了，只能等待
                condition.await();
            }
            // 2、--操作
            number--;
            System.out.println(Thread.currentThread().getName()+"\t" + number);
            // 3、通知唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
// 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1一个减1，来5轮
public class ProConsumerDemo {
    public static void main(String[] args) throws Exception{
        ShareDate shareDate = new ShareDate();
        new Thread(() ->{
            for (int i = 1; i < 6; i++) {
                try {
                    shareDate.increment();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"AA").start();
        new Thread(() ->{
            for (int i = 1; i < 6; i++) {
                try {
                    shareDate.decrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"BB").start();
    }
}
//结果：
AA	1 生产一个
BB	0 消费一个
AA	1
BB	0
AA	1
BB	0
AA	1
BB	0
AA	1
BB	0
```

阻塞队列方式：

#### 6、Synchronized 和 Lock有什么区别？用新的Lock有什么好处？

* Synchronized 是关键字，属于JVM层面的，底层通过(monitorenter & monitorexit)两个指令来完成的。monitorenter(底层通过monitor对象来完成的，其实 wait/notify 等待方法也依赖于 monitor对象，只有在同步块或方法才能调用wait/notift等方法)
* Lock是具体类（在java.util.concurrent.locks包下）是API层面的锁
* Synchronized 是不需要手动释放锁，系统自动让线程释放对锁的占用；而ReentrantLock 需要手动释放锁，所以有导致出现死锁的现象（Lock和UnLock配合try/finally语句块来完成）。
* Synchronized 不可以中断，除非抛出异常或者正常运行完成；而ReentrantLock可中断的，可以设置超时方法tryLock(long timeout,TimeUnit unit)、lockInterruptibly()放代码块中，调用interrupt 方法中断。
* synchronized是非公平锁；而ReentrantLock可以是非公平和公平锁，默认非公平锁。
* 锁绑定多个条件condition：synchronized没有；Reentrant用来实现分组唤醒需要唤醒的线程，可以精确唤醒，synchronized要么随机唤醒一个要么唤醒全部。

#### 7、ReentrantLock新的有什么好处？案例演示

> 锁绑定多个条件condition，condition是ReentrantLock独有的。

题目：多线程之间顺序调用，实现A > B > C 三个线程启动

要求：

AA打印5次，BB打印10次，CC打印15次，紧接着10轮。

#### 8、第三种获得多线程的方式 Callable接口

> 复习线程创建方式：
>
> * 继承Thread类创建线程
> * 实现Runnable接口创建线程，没有返回值
> * 使用Callable和Future创建线程，有返回值
> * 使用线程池例如用Executor框架

```java
class MyThread2 implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("=========");
        return 888;
    }
}
public class SyncAndReentrantLockDemo {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //
        FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
        Thread thread = new Thread(futureTask,"AA");
        thread.start();
        System.out.println(futureTask.get());

    }
}
```

> 高手都是：传参、接口

#### 9、JDK 8新特性

Java8之前接口不允许有实现的，而Java8 接口默认是可以有实现，主要兼容Lombda表达式；支持多注解

#### 10、接口和抽象类有哪些区别？

抽象类：可定义构造器；抽象方法和具体方法；定义成员变量；

除了在语法的区别：意义上不同，接口是描述某些共同事物之间共同特征；抽象类是定义抽象概念的

#### 11、HashMap 和 Hashtable 区别？

* Hashtable线程同步的，HashMap非线程同步
* Hashtable不允许<key,value>为空，HashMap允许<key,value>有空
* Hashtable数组的默认大小11，增加方式old*2+1，HashMap中数组默认大小16，增长方式是2幂次方
* Hashtable使用Enumeration，HashMap使用iterator

#### 12、HashMap 1.7 和 1.8 区别？

* JDK 1.7 ：HashMap底层是【数组+链表】实现的

* JDK 1.8 ：HashMap底层维护【数组+链表+红黑树】，当链表长度大于阈值默认为8时，考虑是否转换为红黑树，如果满足数组长度大于64，那么就转红黑树。红黑树目标减少搜索时间。

#### 13、HashMap 长度为什么是2的幂次方

减少哈希碰撞问题，因为如果是奇数的话，在元素进行&运算的时候，得到结果的出现很多的Hash相同；只有当是2幂次方时候，才能看到后面几位，而不需要全部计算。

## 五、线程池

为什么用线程池？线程池主要是控制运行的线程数量，处理过程中将任务放入队列。

优点：线程复用；控制最大并发数；方便管理线程

#### 1、线程池3个常用方式

Java中的线程池是通过Executor框架实现的，该框架中用到Executor、Executors、ExecutorService、ThreadPoolExecutor这几个类。（线程池底层是ThreadPoolExecutor）

```java
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime());
        // 1、一池5个处理线程
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        // 2、一池一个线程(如周日，银行只开一个窗口办理，不管多少请求，只有一个窗口进行办理)
        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();
        // 3、一池N线程
        ExecutorService threadPool3 = Executors.newCachedThreadPool();
        // 模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程
        try {
            for (int i = 1; i <= 10; i++) {
                // 10个用户执行execute(类似请求提交材料)
                int temp = i;
                threadPool.execute(() ->{
                    System.out.println(Thread.currentThread().getName()+"\t 办理业务"+temp);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            threadPool.shutdown();
        }
    }
}

```

**总结：**

* newFixedThreadPool：执行长期的任务，性能好
* newSingleThreadExecutor：一个任务一个任务执行的场景
* newCachedThreadPool：执行很多短期异步的小程序或负载较轻的服务场景



（1）newFixedThreadPool底层源码

newFixedThreadPool底层5个参数，LinkedBlockingQueue阻塞队列

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

（2）newSingleThreadExecutor底层源码

newSingleThreadExecutor底层5个参数，LinkedBlockingQueue阻塞队列

```java
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

（3）newCachedThreadPool底层源码

底层是SynchronousQueue同步队列

```java
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

#### 2、线程池参数有哪些你了解吗？（重点）

面试题：线程池的工作原理，几个重要参数，然后给了具体参数分析线程会怎么做，最后问阻塞队列的作用是什么？

百度：线程池用过吗？有什么参数？底层如何实现？

**线程池7大参数源码如下：**

```java
public ThreadPoolExecutor(		int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

参数作用：

* corePoolSize：线程池中的常驻核心线程数（类似银行每天都可以办理的那两个窗口是核心的，其他窗口周末休息）
* maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1
* keepAliveTime：多余的空间线程的存活时间
* unit：KeepAliveTime的单位
* workQueue：任务队列，被提交但尚未被执行的任务（银行办理业务时，你取号等待叫到号）
* threadFactory：表示生成线程池中工作线程工厂，用于创建线程（一般默认即可）
* handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（类似银行队列区满，以及候客区也满了，装不下了。此时处理就加大办理窗口）

#### 3、线程池底层工作原理？

案例：用银行栗子来说明吧。假设银行有5个线程窗口，其中有两个核心线程窗口周末时是正常办理业务，然后现在来了一堆客户办理业务，看到核心窗口正在办理业务，后面来的客户就候客区排队等待。那么银行现在请求非核心窗口过来帮忙加班办理业务。有两种情况，一，如果加班的非核心窗口办理等10分钟，没有人来那么就下班，二，非核心窗口办理业务了，但是仍然有大量客户过来，把候客区都排满了，此时处理方法就是执行“拒绝策略”。

原理重要：

1、创建线程池后，当执行execute方法添加请求任务时，线程池的任务如下

1.1 如何正在运行的线程数量小于核心线程(corePoolSize)，它该任务马上被处理

1.2 如果正在运行的线程数量大于或等于(corePoolSize)，那么将该任务放入队列

1.3 如果放入队列，但队列已经满了，但如果正在运行的线程数量小于最大线程数量(maximumPoolSize)，那么会请求创建非核心线程来协助运行任务

1.4 如果放入队列，但队列已经满了，但如果正在运行的线程数量大于最大线程数量(maximumPoolSize)，那么线程池会启动饱和拒绝策略来执行

2、当一个线程完成任务时，它会从队列取出下一个任务来执行

3、如果线程闲着的话，当达到一定时间(keepAliveTime)时，被停止非核心线程，最后就是收缩到核心线程(corePoolSize)



#### 4、拒绝策略知道吗？

* AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行

* CallerRunsPolicy：”调用者运行“一种调节机制，该策略即不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
* DiscardOlddestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再试提交当前任务
* DiscardPolicy：直接丢任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案

#### 5、在工作中，上面你提到的三种创建线程池方式，你用哪一种？

一种都不用？为什么？使用阿里巴巴开发手册规定的定义线程池方式，线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理让写的同学更加明确线程池的运行规则，避免资源耗尽的风险。

Executors返回线程池对象的弊端：

* FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
* CachedThreadPool 和 ScheduleThreadPool：允许的创建线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。

手写线程池和设置拒绝策略：

```java
public class MyThreadPoolDemo02 {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                1L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() ->{
                    System.out.println(Thread.currentThread().getName()+"\t办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
```

你是怎么合理配置线程池，你是如何考虑的呢？

结合我们系统内存来设定的，首先运行一些代码，知道服务器是几核的

```java
// 比如查看当前系统是几核的
System.out.println(Runtime.getRuntime().availableProcessors());
```

如果IO密集型的如何配置？第一种：由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能地线程，如CPU核数*2；第二种：该任务需要大量IO，即大量的阻塞，也就是大部分线程都阻塞，故需要多配置线程数：CPU核数/1-阻塞系数【阻塞系数0.8~0.9】

#### 6、总结：死锁编码及定位分析

（1）产生死锁主要原因？

死锁是指两个或两个以上的进程在执行过程中，因竞夺资源而造成的一种互相等待的现象，若没有外力干涉那他们都无法推进下去。

原因：系统资源不足、进程运行推进的顺序不适合、资源分配不当。

（2）死锁代码

```java
class HoldLock implements Runnable{
    private String lockA;
    private String lockB;
    public HoldLock(String lockA,String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }
    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName()+"\t自己持有："+lockA+"\t尝试获得"+lockB);
            try {TimeUnit.SECONDS.sleep(3);} catch (InterruptedException e) {e.printStackTrace();}
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName()+"\t自己持有："+lockB+"\t尝试获得"+lockA);
            }
        }
    }
}
public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new HoldLock(lockA,lockB),"ThreadAA").start();
        new Thread(new HoldLock(lockB,lockA),"ThreadBB").start();
    }
}
```

（3）解决

Jps 命令定位进程号：通过JPS查看后天运行端口号

```java
 > jps -l
38000 com.haxdeu.interview2.pool.DeadLockDemo
```

Jstack 找到死锁查看

```java
jstack 38000
```

![Snip20210930_30.png](http://ww1.sinaimg.cn/large/006FuVcvgy1guz26s8e4oj61700hqgs802.jpg)



## 六、JVM

#### 1、复习JVM结构

> 什么是垃圾？

垃圾就是在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能内存溢出。

> 为什么需要GC？

* 因为不断地进行分配内存空间，如果不进行GC回收，内存可能可快会被消耗完。
* 释放没有用的对象，及时清楚内存里的记录碎片。
* 如果不进行GC回收，那么在业务越来越复杂的时候，会造成STW的GC，所以需要不断尝试对GC进行优化。

> 内存泄漏：垃圾对象无法被清除，导致内存不断被占用，直到出现内存溢出，从而造成程序崩溃。

#### 2、如何判断哪些是垃圾对象？

（1）引用计数算法：对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。

优点：判断效率高，回收没有延迟

缺点：需要单独的字段存储计数器这样增加空间的开销；每次赋值需要更新计数器这样会增加时间开销；还有就是引用计数器有一个严重的问题，**无法处理循环引用**情况。

（2）可达性分析算法：有效解决在引用计数算法中循环引用的问题，防止内存泄漏发生。

原理：可达性分析是以根对象集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。如果对象没有任何引用链（Reference Chain）相连，则可以标记为垃圾对象。

GC Roots包括以下几个类：

* 虚拟机栈中引用的对象
* 本地方法栈
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 所有被同步锁synchronize持有的对象
* 临时性的加入：比如，分代收集和局部回收（Partial GC）

注意：

* 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。如果这一点不能满足的话分析结果的准确性就无法保证
* 这一点也是导致GC进行时必须“Stop The World”的一个重要原因（即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的）

> Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。
>
> 停顿的原因:

#### 3、哪些对象可以成为GCRoots的，你是如何理解？

* 虚拟机栈（栈中的局部变量区或叫局部变量表）中引用对象
* 方法区中的类静态属性引用对象
* 方法区中常量引用对象
* 本地方法栈中INI(Native方法)引用对象

```java
public class GCRootsDemo {
    private byte[] byteArray = new byte[100*1024*1024];
    // 1、类的静态引用
    private static GCRootsDemo t2;
    // 2、方法区中常量引用对象
    private static final GCRootsDemo t3 = new GCRootsDemo();
    // 3、方法存在栈里面的，
    public static void m1() {
        //t1就是JVM引用的对象
        GCRootsDemo t1 = new GCRootsDemo();
        System.gc();
        System.out.println("第一次GC");
    }
}
```

#### 4、了解JVM调优及参数配置吗？你是如何盘点查看JVM系统默认值的？

JVM参数类型主要有三种：

（1）标配参数：如 [java -version]

（2）X参数：如 [-Xint]解释执行、[-Xcomp]第一次使用就编译成本地代码

（3）XX参数（重点）

* Boolean类型：
  * `-XX:+ or -某个属性值`，加表示开启，减表示关闭

如何查看JVM参数是否开启？或具体值？jps and jinfo 

![Snip20211001_31.png](http://ww1.sinaimg.cn/large/006FuVcvgy1guzvpnks6bj61lq0dudol02.jpg)

上面是通过命令行查看GC信息，现在我们配置JVM参数：开发IDEA --> run --> EditConfigurations 然后添加一下参数：`-XX:+PrintGCDetails`，PrintGCDetails表示打印GC信息

* KV设值类型：

  * 公式 [-XX:属性 key=属性value] ，用于设置大小，如元空间大小为多少等。

    * ```java
      # 设置元空间大小为1024m
      -XX:MetaspaceSize=1024m
      ```

    * ```java
      # 设置多大年龄可以进入老年区
      -XX:MaxTenuringThreshold=15
      ```

    * 

（4）盘点查看JVM系统默认值

* java -XX:+PrintFlagsInitial：用于查看初始值(做调优时是常用的)
* java -XX:+PrintFlagsFinal -version：主要查看修改更新的内容(”=“未修改 和 ”:=“修改过)
* java -XX:+PrintCommandLineFlags -version：查看各个区使用情况及当前垃圾回收器使用那一种(JDK11默认使用`-XX:+UseG1GC`，JDK8默认UseParalleLGC )

#### 5、你平时使用JVM常用配置参数有哪些？

JDK8之后最初的永久代被取消了，由元空间取代。永久代和元空间区别是？永久代是在堆内存的，元空间不在虚拟机中，而是在本地物流内存。

-Xms：设置初始大小内存，默认物理内存1/64（等价-XX:InitialHeapSize）

-Xmx：设置最大分配内存，默认物理内存1/4（等价-XX:MaxHeapSize）

-Xss：设置单个线程栈大小（等价-XX:ThreadStackSize）

-Xmn：设置年轻代

-XX:MetaspaceSize：设置元空间大小

```java
# 配置,UseSerialGC串行垃圾回收器
-Xms128m -Xmx4096 -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC
```

-XX:+PrintGCDetails：输出GC收集日志信息

-XX:SurvivorRatio：

-XX:NewRatio：配置年轻代和老年代在堆结构的占比

-XX:MaxTenuringThreshold：设置垃圾最大年龄（JDK11范围[0-16]）

#### 6、强引用、软引用、弱引用、虚引用分别是 什么吗？

```java
// b是引用指向实例对象new B();
B b = new B();
```

引用在`java.lang.ref`包下。

（1）强引用：是指垃圾收集器不会去回收的对象，就算内存不足，出现OOM也不会对该对象进行回收。Java大部分都是强引用的，因此会出现Java内存泄露的原因。

```java
public class GCRootsDemo {
    public static void main(String[] args) throws Exception{
        Object o1 = new Object();//强引用
        Object o2 = o1;//引用赋值
        System.gc();//手动GC
        System.out.println(o2);
    }
}
```

（2）软引用：比强引用弱一点，只要系统内存足够我就不回收，等系统内存不足才回收。由`java.lang.ref.SoftReference`类实现的。

```java
public class GCRootsDemo {
    public static void main(String[] args) throws Exception{
        Object o1 = new Object();//强引用
        SoftReference<Object> ref = new SoftReference<>(o1);
        System.out.println(o1);
        System.out.println(ref.get());
        o1 = null;
        System.gc();
        System.out.println(ref.get());
    }
}
```

（3）弱引用：只要有GC必定被回收

（4）虚引用：引用不可达，统统被干掉

#### 7、OOM

常见异常：

* java.lang.StackOverflowError：方法的调用大于栈的深度

* java.lang.OutOfMemoryError: Java heap space：对象太多了

  * ````java
    //参数配置：-Xmx10m -Xmx10m -XX:+PrintGCDetails
    public class JavaHeapSpaceDemo {
        public static void main(String[] args) {
            String str = "hello";
            while (true) {
                str += str + new Random().nextInt(11111) + new Random().nextInt(22222);
                str.intern();
            }
        }
    }
    ````

* java.lang.OutOfMemoryError: GC overhead limit exceeded（GC回收时间过长抛出的，超过89%的时间来做GC并且回收不到2%的堆内存）

* java.lang.OutOfMemoryError: Direct buffer memory（元空间与永久代区别就是，元空间不在虚拟机内存中而是在本地内存）

* java.lang.OutOfMemoryError: Metaspace

永久代（JDK8后元空间）：存放信息有，虚拟机加载的类信息、常量池、静态变量、即时编译后的代码



#### 8、垃圾收集器（重点）

垃圾回收算法与垃圾收集器区别：GC算法(引用计数/标记复制/标记清除/标记整理)是内存回收的方法论，垃圾收集器就是最终的解决问题。

4种主要垃圾收集器：serial、parallel、CMS、G1

（1）串行垃圾回收器（Serial）：它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有用户线程。不使用于服务器环境。

（2）并行垃圾回收器（Parallel）：多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场景。

（3）并发垃圾回收器（Concurrent Mark Sweep简称CMS）：用户线程和垃圾收集线程同时执行，不需要停顿用户线程。互联网公司多用它，适用于对响应时间有要求的场景

（4）G1垃圾回收器（Garbage 1）：G1 垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。



> 如何查看默认垃圾收集器?生产上如何配置垃圾收集器？

查看 Java 虚拟机默认垃圾收集器命令：`java -XX:+PrintCommandLineFlags -version`，一下是JDK11

```java
> java -XX:+PrintCommandLineFlags -version
-XX:G1ConcRefinementThreads=8 
  -XX:GCDrainStackTargetSize=64 
    -XX:InitialHeapSize=268435456 
      -XX:MaxHeapSize=4294967296 
        -XX:+PrintCommandLineFlags 
          -XX:ReservedCodeCacheSize=251658240 
            -XX:+SegmentedCodeCache 
              -XX:+UseCompressedClassPointers 
                -XX:+UseCompressedOops 
                  -XX:+UseG1GC 
openjdk version "11.0.12" 2021-07-20 LTS
OpenJDK Runtime Environment Corretto-11.0.12.7.2 (build 11.0.12+7-LTS)
OpenJDK 64-Bit Server VM Corretto-11.0.12.7.2 (build 11.0.12+7-LTS, mixed mode)
```

回顾4大垃圾回收算法：引用计数/复制拷贝/标记清除/标记整理

垃圾收集器算法：Serial/parallel/CMS/G1

Java的GC回收类型主要有以下几种：

```java
// 查看默认垃圾收集器，Java11默认使用UseG1GC
java -XX:+PrintCommandLineFlags -version
```

**UseSerialGC、UseParallelGC、UseConcMarkSweepGC、UseparNewGC、UseparallelOldGC、UseG1GC**

#### 垃圾收集器使用情况：

> 年轻代：Serial Copying、Parallel Scavenge、parNew 
>
> 老年代：Serial MSC(Serial Old) 、Parallel Compacting(Parallel Old) 、 CMS 

控制台打印说明：

* DefNew = Default New Generation
* Tenured = Old
* parNew = parallel New Generation
* PSYoungGen = Parallel Scavenge
* ParaOldGen = Parallel Genneration

#### 新生代细讲

> 年轻代：Serial Copying、Parallel Scavenge、parNew 

（1）串行GC（Serial）/（Serial Copying）

一个单线程的收集器，在进行垃圾收集时候，必须暂停其他线程(STW)所有工作线程直到垃圾收集结束。

配置参数：

```java
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC
```

（2）并行GC（ParNew）

使用多线程进行垃圾回收，在垃圾收集时，会Stop-the-World暂停其他所有线程的工作线程直到收集结束。常用应用场景就是配合老年代的CMSGC工作

```java
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC
```

（3）并行回收GC（Parallel）/（Parallel Scavenge）

也是一种新生代垃圾收集器，使用复制算法，也是一个并发的多线程的垃圾收集器。（新老年代都并行化收集）

JVM参数：-XX:+UseParallelGC or -XX:+UseParallelPldGC

```java
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC
```

> 注：相互激活的，只要你在老年代或年轻代设置，会相互激活

#### 老年代细讲

> 老年代：Serial MSC(Serial Old) 、Parallel Compacting(Parallel Old) 、 CMS 

（1）串行GC（Serial Old）/（Serial MSC）

```
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC
```

（2）并发GC（Parallel Old）/（Parallel MSC）

（3）并发标记清除GC（CMS），用来老年代

CMS收集器（Concurrent Mark Sweep：并发标记清除）并发收集停顿时间短，它是与用户线程一起执行的。

开启该收集器JVM参数：-XX:+UseConcMarkSweepGC 开启该参数后自动将 -XX:+UseParNewGC打开

```java
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC
```

#### 总结：GC 垃圾收集器如何选择

组合选择：

* 单CPU或内存小，单机程序：-XX:+UseSerialGC
* 多CPU，需要最大吞吐量：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC
* 多CPU，最求低停顿时间，需快速响应如互联网应用：-XX:+UseConcMarkSweepGC 或 -XX:+ParNewGC

#### 垃圾收集器 G1(Java11默认使用)

G1 是一种服务器的垃圾收集器，引用在多处理器和大容量内存环境，实现高吞吐量，尽可能满足垃圾收集暂停时间要求。

特点：

* **G1 在Stop The World添加预测机制，用户可以指定期望停顿时间**。
* G1 整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片

JVM参数配置：

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseG1GC
```

G1收集器运作过程：

* 初始标记(Initial Making)
* 并发标记(Concurrent Marking)
* 最终标记(Final Making)
* 筛选回收(Live Data Counting and Evacuation)

设置参数：[官网文档](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)

1. | Option and Default Value            | Description                                                  |
   | ----------------------------------- | ------------------------------------------------------------ |
   | -XX:+UseG1GC                        | Use the Garbage First (G1) Collector                         |
   | -XX:MaxGCPauseMillis=n              | 设置最大GC停顿时间，JVM是尽可能（不保证）n毫秒               |
   | XX:InitiatingHeapOccupancyPercent=n | Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes 'do constant GC cycles'. The default value is 45. |
   | -XX:NewRatio=n                      | Ratio of new/old generation sizes. The default value is 2.   |
   | -XX:SurvivorRatio=n                 | Ratio of eden/survivor space size. The default value is 8.   |
   | -XX:MaxTenuringThreshold=n          | Maximum value for tenuring threshold. The default value is 15. |
   | -XX:ParallelGCThreads=n             | Sets the number of threads used during parallel phases of the garbage collectors. The default value varies with the platform on which the JVM is running. |
   | -XX:ConcGCThreads=n                 | Number of threads concurrent garbage collectors will use. The default value varies with the platform on which the JVM is running. |
   | -XX:G1ReservePercent=n              | Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure. The default value is 10. |
   | -XX:G1HeapRegionSize=n              | 设置G1区域大小，值是2的幂，范围1MB-32MB                      |

####  G1 比 CMS 优势

（1）G1 不会产生内存碎片

（2）可以精确控制STW。该收集器是把整个（新生代、老年代）划分多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。