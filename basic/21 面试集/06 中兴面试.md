## 面试1.0

### **一、springboot 自动配置原理(@springbootApplication)**

@SpringBootConfiguration

@EnableAutoConfiguration

@ComponentScan

1、@SpringBootConfiguration：标志该类为配置类 作用与@Configuration一样

2、@EnableAutoConfiguration：关注两个核心注解：

@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class) 

​	@AutoConfigurationPackage：就是将主配置类（@SpringBootConfiguration标注的类）的**所在包及下面所有子包**作为自动配置的包进行管理

​	@Import(AutoConfigurationImportSelector.class) ： 导入了AutoConfigurationImportSelector(自动配置选择器)，selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有META-INF/spring.factories的jar包下面key是EnableAutoConfiguration全名的，所有自动配置类。

3、@ComponentScan：指定包下面需要装配的组件注册到容器中；

### **二、redis缓存穿透、缓存击穿、缓存雪崩**

缓存穿透:

key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。

缓存击穿:

key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

缓存雪崩: 

当缓存服务器重启或者大量缓存在同一时间过期失效，在失效的时候会给数据库带来很大压力

解决方案：

​	1、缓存穿透:（两种方案）

​		**一方案：**采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

​		**二方案：**如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，可以把过期时间设置的尽可能小一点

​	2、缓存击穿：

​		**一方案：**利用redis分布式锁(互斥锁)

​		**二方案：**双份缓存

​	3、缓存雪崩：

​		**一方案：**将缓存的时间分散开，降低过期时间的重复率

​		**二方案：**用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上



### **三、synchronized实现原理**

synchronized可以作用与**同步代码块**和**方法**，方法分为实例方法和静态方法

实例方法：给当前实例对象加锁，进入同步方法前要获得当前实例的锁；

静态方法：给当前类加锁，要获取当前类的对象；

同步代码块：对括号内置对象加锁；

原理：synchronized在jdk1.6之后是有较大的优化，分为无锁、偏向锁、轻量级锁、重量级锁；

当我们创建要一个对象时，markword中 偏向锁状态是0（低三位） ，锁的标志位为01(低两位)，表示该对象还未加偏向锁，当有一个线程来执行操作的区域时，会将该线程的线程id记录在锁对象的markword中，只要判断该线程id是否与锁对象中的线程id相等，就可以知道该线程是否持有锁，如果不相等需要检查对象是否可偏向锁的标志位(我的理解是如果是偏向锁的状态，即为竞争会升级成轻量级锁，如果不为偏向锁的状态，则利用cas去获取锁的markword信息)；

然后讲一下存在竞争的情况下原持有偏向锁的线程，会在一个全局安全点停止拥有锁的线程，遍历线程栈，判断是否存在锁的记录，如果存在需要撤销锁的设置，更改锁对象markword的信息，使其变成无锁的状态；然后唤起线程，将当前锁升级成轻量级锁；

参考如下:

![image-20201109232204088](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20201109232204088.png)

升级为轻量级锁后，会在当前线程的栈帧中开辟一个LockRecord的空间用来存放锁对象的markword信息并且将LockRecord中的owner指针指向锁对象，然后利用cas操作让锁对象的markword中替换成栈中LockRecord的指针；

当竞争非常激烈，会导致很多线程在自旋，导致资源的浪费(cpu内核态和用户太的转化，过于底层啦...)，会升级成重量级锁；

在同步代码快中class文件中是以monitorenter和monitorexit,执行monitorenter将会尝试获取对象对应的monitor所有权(获取对象的锁)，然后锁对象的markword指向互斥量（monitor对象）的指针，并且会在ObjectMonitor(Hotspot实现Monitor的对象)对象中的_count 加1，因为是可重入性的所以每次不用加锁释放锁，只要加1就好，释放锁需要把 _count清零，完成释放。

同步方法的原理：方法级的同步是隐式的，无须通过字节码指令来控制，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用的时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先持有monitor对象，然后才能执行方法，最后当方法执行完（无论是正常完成还是非正常完成）时释放monitor对象。在方法执行期间，执行线程持有了管程，其他线程都无法再次获取同一个管程。

### 四、JVM的主要组成部分和作用

jvm分为两个子系统和两个组件

1、Class loader（类装载）

2、Execution engine（执行引擎）

3、Runtime data area(运行时数据区)

4、Native Interface(本地接口)

作用:首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

### **五、JVM的运行时数据区**

线程私有：

1、程序计数器（Program Counter Register）：每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。**PC寄存器的内容总是指向下一条将被执行指令的地址**，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。

2、虚拟机栈（Java Virtual Machine Stacks）：每个方法执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息；

​	动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接

​	方法出口：

​		1>方法返回指令 ： 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为		正常完成出口。

​		2>异常退出 ： 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。

注意：

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

3、方法区（Methed Area）

属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

4、本地方法区（Native Method Stack）

为虚拟机调用 Native 方法服务的；

5、堆（Java Heap）

对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。

### **六、判断对象是否可以回收**

1、引用计算器法

​	当对象引用了则这个对象加计数加1.再次引用了则计数变为2，如果不再引用了则计数减1，知道这个计数变为0，则对对象回收。

​	问题：循环依赖

2、可达性分析算法

​	在Java中，是通过可达性分析（Reachability Analysis）来判定对象是否存活的。该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。
**标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。**
**1. 第一次标记并进行一次筛选。**
筛选的条件是此对象是否有必要执行finalize()方法。
当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。
**2. 第二次标记**
如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。



### **七、垃圾回收算法**

1、标志-清除算法

​	标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间；

​	缺点：容易产生内存碎片

2、复制算法

​	它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉

3、标志整理算法

4、分代算法

### **八、MySQL Explain中的type属性**

> 该列称为**关联类型或者访问类型**，它指明了MySQL决定如何查找表中符合条件的行，同时**是我们判断查询是否高效的重要依据**。

以下为常见的取值

- ALL：**全表扫描**，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型，因为这样的查询，在数据量最大的情况下，对数据库的性能是巨大的灾难。

- index：**全索引扫描**，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。

- range：**范围扫描**，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 `=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN、IN()` 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。

- ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。

- eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时会出现该值，非常高效。

- const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。

- NULL：在执行阶段不需要访问表。

  

###  **九、Spring bean的生命周期**

1、实例化bean：通过反射(构造器反射)

​		通过获取BeanDefinition对象中的信息进行实例化，实例化对象被封装在BeanWrapper对象中

2、属性赋值(依赖注入)，ioc注入

​		根据BeanDefinition中的信息进行依赖注入

3、if bean   aware接口 是为了获取容器对象的信息；

​		实现了BeanNameWare接口：会要实现它的setBeanName()方法，传递的参数就是Spring配置文件中Bean的id值，我的理解是传入bean的名称；

​		实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传入beanFactory本身；

​		实现了ApplicationContextAware接口，会调用setApplicationContext(),传入spring的上下文；

4、if Bean 关联了BeanPostProcessor接口，将会调用postProcessorBeforInitialization()方法：

​		当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理

5、if Bean 实现了InitializingBean接口，那么Bean在实例化完成后将会执行接口中的afterPropertiesSet()方法来进行初始化

​		这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 
若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。

6、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。

注意：如果即实现了InitializingBean接口也在配置文件中配置了init-method，会先执行afterPropertiesSet()方法在执行init方法

7、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法

8、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；

9、如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

### **十、spring 如何解决属性循环依赖**

![](C:\Users\tiger\Desktop\微信图片_20201122230730.png)



当aService实例化后会加入到三级缓存中，在属性填充的过程中发现依赖bService（从单例池>二级缓存>三级缓存）,都没发现则创建bService；这时候bService进行属性填充时，发现依赖aService，然后从单例池中查找，没有则从二级缓存中查找，还没有从三级缓存中查找，三级缓存中是一个conrenthashmap，value值放的是lambda表达式，生成代理对象，然后放入二级缓存中，再删除三级缓存对应对象。

### **十一、hashtable和hashmap的区别**

1、hashtable线程安全，hashmap线程不安全

2、hashtable的数组默认长度是11，扩容因子0.75，扩容的数组长度为2*table.length+1；

​		计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length;   hash & 0x7FFFFFFF是为了保证hashcode值都为正数

​	  hashmap的默认长度16，扩容因子0.75，扩容的数组长度为2*table.length



### **十二、springmvc的工作原理**

1、用户请求到前端控制器DispatcherServlet;

2、DispatchServlet收到请求调用HandlerMapping处理器映射；

3、找到对应的Handler返回给DispatchServlet

4、请求HandlerAdapter执行Handler，返回一个modelAndView给DispatcherServlet

5、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。

6、ViewReslover解析后返回具体View。

7、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。



### **十三、Mybatis工作原理**

1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成**Configuration**，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着<select | update | delete | insert>标签项。

2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。

3、通过SqlSession拿到Mapper代理对象

4、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象

5、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象

6、JDBC执行sql。

### **十四、类加载机制**

加载:在硬盘上查找并通过IO读入字节码文件至JVM虚拟机方法区，同时在堆中创建Class对象

验证：校验字节码文件的正确性

准备：为类的静态变量分配内存，并将其初始化为默认值。此阶段就是为了给静态类变量分配内存，并且设置改变量的初始值，对于final static修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。

解析：把类中的符号引用转换为直接引用

初始化：对类的静态变量初始化为指定的值，执行静态代码块

### **十五、类加载器**

1、引导类加载器 Bootstrap ClassLoader 

负责加载jre/lib目录下的核心类库，比如rt.jar、charsets.jar等(jre自带的jar包)

2、扩展类加载器 Extension ClassLoader

负责加载jre/lib/ext目录下的JAR类包

3、应用类加载器 Application ClassLoader

负责加载ClassPath路径 类路径下的class字节码文件，主要就是加载自己写的类

4、自定义加载器：负责加载用户自定义路径下的class字节码文件